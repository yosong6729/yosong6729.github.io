<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[자바 ORM 표준 JPA 프로그래밍 - 기본편] 프록시와 연관관계 관리 | Yosong6729 Blog</title>
<meta name=keywords content="JPA"><meta name=description content='해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
프록시 Memer를 조회할 때 Team도 함께 조회 해야 할까? public void printUserAndTeam(String memberId) { Member member = em.find(Member.class, memberId); Team team = member.getTeam(); System.out.println("회원 이름: " + member.getUsername()); System.out.println("소속팀: " + team.getName()); } 회원과 팀 함께 출력 public void printUser(String memberId) { Member member = em.'><meta name=author content="yosong6729"><link rel=canonical href=https://yosong6729.github.io/post/%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A6%AC/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yosong6729.github.io/post/%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A6%AC/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="[자바 ORM 표준 JPA 프로그래밍 - 기본편] 프록시와 연관관계 관리"><meta property="og:description" content='해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
프록시 Memer를 조회할 때 Team도 함께 조회 해야 할까? public void printUserAndTeam(String memberId) { Member member = em.find(Member.class, memberId); Team team = member.getTeam(); System.out.println("회원 이름: " + member.getUsername()); System.out.println("소속팀: " + team.getName()); } 회원과 팀 함께 출력 public void printUser(String memberId) { Member member = em.'><meta property="og:type" content="article"><meta property="og:url" content="https://yosong6729.github.io/post/%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A6%AC/"><meta property="og:image" content="https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-15T18:03:01+09:00"><meta property="article:modified_time" content="2024-09-15T18:03:01+09:00"><meta property="og:site_name" content="Yosong6729 Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[자바 ORM 표준 JPA 프로그래밍 - 기본편] 프록시와 연관관계 관리"><meta name=twitter:description content='해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
프록시 Memer를 조회할 때 Team도 함께 조회 해야 할까? public void printUserAndTeam(String memberId) { Member member = em.find(Member.class, memberId); Team team = member.getTeam(); System.out.println("회원 이름: " + member.getUsername()); System.out.println("소속팀: " + team.getName()); } 회원과 팀 함께 출력 public void printUser(String memberId) { Member member = em.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yosong6729.github.io/post/"},{"@type":"ListItem","position":2,"name":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 프록시와 연관관계 관리","item":"https://yosong6729.github.io/post/%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A6%AC/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 프록시와 연관관계 관리","name":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 프록시와 연관관계 관리","description":"해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.\n프록시 Memer를 조회할 때 Team도 함께 조회 해야 할까? public void printUserAndTeam(String memberId) { Member member = em.find(Member.class, memberId); Team team = member.getTeam(); System.out.println(\u0026#34;회원 이름: \u0026#34; + member.getUsername()); System.out.println(\u0026#34;소속팀: \u0026#34; + team.getName()); } 회원과 팀 함께 출력 public void printUser(String memberId) { Member member = em.","keywords":["JPA"],"articleBody":" 해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.\n프록시 Memer를 조회할 때 Team도 함께 조회 해야 할까? public void printUserAndTeam(String memberId) { Member member = em.find(Member.class, memberId); Team team = member.getTeam(); System.out.println(\"회원 이름: \" + member.getUsername()); System.out.println(\"소속팀: \" + team.getName()); } 회원과 팀 함께 출력 public void printUser(String memberId) { Member member = em.find(Member.class, memberId); Team team = member.getTeam(); System.out.println(\"회원 이름: \" + member.getUsername()); } 회원만 출력 회원과 팀을 함께 출력하는 상황에서는 Member객체를 em.find()로 가져올때 Team도 DB에서 가져와서 괜찮은데 회원만 출력하고 싶을때는 Team의 정보까지 가져오기 때문에 최적화가 되지 않는다.\n프록시 기초 em.find() vs em.getReference() em.find(): 데이터베이스를 통해서 실제 엔티티 객체 조회 em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회 em.find()를 사용하는 시점에는 select 쿼리를 DB에 날리고 진짜 객체를 받고 em.getReference()를 사용하는 시점에는 select 쿼리를 DB에 날리지 않고 가짜(프록시) 객체를 받는다. 그리고 member.getUsername()과 같은 Member객체의 필드값이 필요하면 select 쿼리를 DB에 날린다.\n프록시 특징 실제 클래스를 상속 받아서 만들어짐 실제 클래스와 겉 모양이 같다. 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨 (이론상) 프록시 객체는 실제 객체의 참조(target)를 보관 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출 프록시 객체 초기화 Member member = em.getReference(Member.class, “id1”); member.getName(); em.getReferemce()로 프록시 객체를 가져오고 member.getName()을 가져와야하는데 Member target이 null 이기때문에 JPA가 영속성 컨텍스트에 Member 객체를 요청해서 영속성 컨텍스트가 DB를 조회해서 실제 엔티티객체를 생성하고 Member target에 연결해준다. 위 과정이 완료되고 target.getName()을 통해 실제 객체에서 값을 가져오온다.\n프록시의 특징 프록시 객체는 처음 사용할 때 한 번만 초기화 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함 (== 비교 실패, 대신 instance of 사용) 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환 Member m1 = em.find(Member.calss, member1.getId()); log.info(\"m1 = {}\", m1.getClass()); Member reference = em.getReference(Member.class, member1.getId()); log.info(\"reference = {}\", (m1 == reference)); //log 결과 m1 = class hellojpa.Member reference = class hellojpa.Member 위 결과 처럼 나오는 이유는 2가지 이유가 있다. 첫번째 이유는 Member를 영속성 컨텍스트에 올려놨는데 그걸 프록시로 가져와 봐야 아무 이점이 없고 원본을 반환하는게 성능 최적화 입장에서도 좋다. 두번째는 JPA에서는 같은 영속성 컨텍스트 안에서 == 비교를 TRUE로 보장해준다. 위 코드의 예시와 반대로 em.getReference()로 프록시 객체를 받고 em.find()를 요청해도 프록시 객체를 받는다.\n영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생(하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림) Member refMember = em.getReference(Member.class, member1.getId()); //em.detech(refMember); 준영속 상태 em.clear(); refMember.getUsername(); // org.hibernate.LazyInitializationException: could not initialize proxy 오류 발생 프록시 확인 프록시 인스턴스의 초기화 여부 확인 PersistenceUnitUtil.isLoaded(Object entity)\nEntityManagerFactory emf = Persistence.createEntityManagerFactory(...) ... Member refMember = em.getReference(Member.classm member1.getId()); log.info(\"isLoaded = {}\", emf.get PersistenceUnitUtil().isLoaded(refMember) // isLoaded = false가 나온다. 프록시 클래스 확인 방법 entity.getClass().getName() 출력(..javasist.. orHibernateProxy…) 프록시 강제 초기화 org.hibernate.Hibernate.initialize(entity);\nMember refMeber = em.getReference(Member.class, member1.getId()); Hibernate.initialize(refMember);//강제 초기화 참고: JPA 표준은 강제 초기화 없음 강제 호출: member.getName() 즉시 로딩과 지연 로딩 Member를 조회할 때 Team도 함께 조회해야 할까? 단순히 member 정보만 사용하는 비즈니스 로직 println(member.getName());\n단순히 Member를 조회할때 연관관계가 걸려있어서 Team까지 조인해서 가져오면 손해이기때문에 JPA는 지연 로딩이라는 옵션을 제공한다.\n지연 로딩 LAZY을 사용해서 프록시로 조회 @Entity public class Member { @Id @GeneratedValue private Long id; @Column(name = \"USERNAME\") private String name; @ManyToOne(fetch = FetchType.LAZY) //** @JoinColumn(name = \"TEAM_ID\") private Team team; .. } Member의 Team에 지연 로딩을 설정하면 em.find()로 member객체를 조회하고 Team객체는 프록시로 받는다.\n지연 로딩 지연 로딩 LAZY을 사용해서 프록시로 조회 Member member = em.find(Member.class, 1L)\nTeam team = member.getTeam(); team.getName(); //실제 team을 사용하는 시점에 초기화(DB 조회)\nMember와 Team을 자주 함께 사용한다면? 즉시 로딩 EAGER을 사용해서 함께 조회 @Entity public class Member { @Id @GeneratedValue private Long id; @Column(name = \"USERNAME\") private String name; @ManyToOne(fetch = FetchType.EAGER) //** @JoinColumn(name = \"TEAM_ID\") private Team team; .. } 즉시 로딩 Member를 조회할때 Team도 조인해서 값을 가져온다.\n즉시 로딩(EAGER), Member조회시 항상 Team도 조회 JPA 구현체는 가능하면 조인을 사용해서 SQL 한번에 함께 조회\n프록시와 즉시로딩 주의 가급적 지연 로딩만 사용(특히 실무에서) 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생 즉시 로딩은 JPQL에서 N+1 문제를 일으킨다. @ManyToOne, @OneToOne은 기본이 즉시 로딩 → LAZY로 설정 @OneToMany, @ManyToMany는 기본이 지연 로딩 지연 로딩 활용 실무에서는 모두 지연 로딩을 사용하는걸 권장\nMember와 Team은 자주 함께 사용 -\u003e 즉시 로딩 Member와 Order는 가끔 사용 -\u003e 지연 로딩 Order와 Product는 자주 함께 사용 -\u003e 즉시 로딩 Member를 조회하면 Team은 즉시 로디잉기때문에 member와 team의 쿼리가 한번에 나오고 orders는 지연 로딩이여서 프록시가 반한된다.\n지연 로딩 활용 - 실무 모든 연관관계에 지연 로딩을 사용해라! 실무에서 즉시 로딩을 사용하지 마라! JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라! (뒤에서 설명) 즉시 로딩은 상상하지 못한 쿼리가 나간다. 영속성 전이: CASCADE 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들도 싶을 때 예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장. 영속성 전이: 저장 @OneToMany(mappedBy=\"parent\", cascade=CascadeType.PERSIST) Child child1 = new Child(); Child child2 = new Child(); Parent parent = new Parent(); parent.addChild(child1); parent.addChild(child2); em.persist(parent); //em.persist(child1); //em.persist(child2); parent 하나만 persist했는데 child1, child2 둘다 persist가 된다. 만약 cascade=CascadeType.PERSIST하지 않고 parent만 persist하면 오류가 난다.\n영속성 전이: CASCADE - 주의! 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐 CASCADE의 종류 ALL: 모두 적용 PERSIST: 영속 REMOVE: 삭제 MERGE: 병합 REFRESH: REFRESH DETACH: DETACH 쓸만한 것은 All, Persist인데 저장만 할때와 삭제하면 안되고 조심해야할때는 Persist쓰고 라이프사이클을 다 맞춰야 하면 All을 쓰면 된다. 그리고 소유자가 한명일때와 라이프사이클이 같을때만 사용한다.\n고아 객체 고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식엔티티를 자동으로 삭제 orphanRemoval = true Parent parent1 = em.find(Parent.class, id); parent1.getChildren().remove(0); //자식 엔티티를 컬렉션에서 제거 DELETE FROM CHILD WHERE ID=? 고아 객체 - 주의 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로보고 삭제하는 기능 참조하는 곳이 하나일 때 사용해야함! 특정 엔티티가 개인 소유할 때 사용 @OneToOne, @OneToMany만 가능 참고: 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께제거된다. 이것은 CascadeType.REMOVE처럼 동작한다. 영속성 전이 + 고아 객체, 생명주기 CascadeType.ALL + orphanRemoval=true 스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거 두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음 도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용 실전 예제 - 5.연관관계 관리 모든 연관관계를 지연 로딩으로 @ManyToOne, @OneToOne은 기본이 즉시 로딩이므로 지연 로딩으로 변경 영속성 전이 설정 Order -\u003e Delivery를 영속성 전이 ALL 설정 Order -\u003e OrderItem을 영속성 전이 ALL 설정 ","wordCount":"1018","inLanguage":"en","image":"https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-15T18:03:01+09:00","dateModified":"2024-09-15T18:03:01+09:00","author":{"@type":"Person","name":"yosong6729"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yosong6729.github.io/post/%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A6%AC/"},"publisher":{"@type":"Organization","name":"Yosong6729 Blog","logo":{"@type":"ImageObject","url":"https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yosong6729.github.io/ accesskey=h title="Yosong6729 블로그 (Alt + H)"><img src=https://yosong6729.github.io/apple-touch-icon.png alt aria-label=logo height=35>Yosong6729 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yosong6729.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://yosong6729.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yosong6729.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yosong6729.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">[자바 ORM 표준 JPA 프로그래밍 - 기본편] 프록시와 연관관계 관리</h1><div class=post-meta><span title='2024-09-15 18:03:01 +0900 KST'>September 15, 2024</span>&nbsp;·&nbsp;yosong6729&nbsp;|&nbsp;<a href=https://github.com/yosong6729/blog/tree/main/content/post/%ed%94%84%eb%a1%9d%ec%8b%9c%ec%99%80%20%ec%97%b0%ea%b4%80%ea%b4%80%ea%b3%84%20%ea%b4%80%eb%a6%ac/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ed%94%84%eb%a1%9d%ec%8b%9c aria-label=프록시>프록시</a><ul><li><a href=#memer%eb%a5%bc-%ec%a1%b0%ed%9a%8c%ed%95%a0-%eb%95%8c-team%eb%8f%84-%ed%95%a8%ea%bb%98-%ec%a1%b0%ed%9a%8c-%ed%95%b4%ec%95%bc-%ed%95%a0%ea%b9%8c aria-label="Memer를 조회할 때 Team도 함께 조회 해야 할까?">Memer를 조회할 때 Team도 함께 조회 해야 할까?</a></li><li><a href=#%ed%94%84%eb%a1%9d%ec%8b%9c-%ea%b8%b0%ec%b4%88 aria-label="프록시 기초">프록시 기초</a></li><li><a href=#%ed%94%84%eb%a1%9d%ec%8b%9c-%ed%8a%b9%ec%a7%95 aria-label="프록시 특징">프록시 특징</a></li><li><a href=#%ed%94%84%eb%a1%9d%ec%8b%9c-%ea%b0%9d%ec%b2%b4-%ec%b4%88%ea%b8%b0%ed%99%94 aria-label="프록시 객체 초기화">프록시 객체 초기화</a></li><li><a href=#%ed%94%84%eb%a1%9d%ec%8b%9c%ec%9d%98-%ed%8a%b9%ec%a7%95 aria-label="프록시의 특징">프록시의 특징</a></li><li><a href=#%ed%94%84%eb%a1%9d%ec%8b%9c-%ed%99%95%ec%9d%b8 aria-label="프록시 확인">프록시 확인</a></li></ul></li><li><a href=#%ec%a6%89%ec%8b%9c-%eb%a1%9c%eb%94%a9%ea%b3%bc-%ec%a7%80%ec%97%b0-%eb%a1%9c%eb%94%a9 aria-label="즉시 로딩과 지연 로딩">즉시 로딩과 지연 로딩</a><ul><li><a href=#member%eb%a5%bc-%ec%a1%b0%ed%9a%8c%ed%95%a0-%eb%95%8c-team%eb%8f%84-%ed%95%a8%ea%bb%98-%ec%a1%b0%ed%9a%8c%ed%95%b4%ec%95%bc-%ed%95%a0%ea%b9%8c aria-label="Member를 조회할 때 Team도 함께 조회해야 할까?">Member를 조회할 때 Team도 함께 조회해야 할까?</a></li><li><a href=#%ec%a7%80%ec%97%b0-%eb%a1%9c%eb%94%a9-lazy%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%b4%ec%84%9c-%ed%94%84%eb%a1%9d%ec%8b%9c%eb%a1%9c-%ec%a1%b0%ed%9a%8c aria-label="지연 로딩 LAZY을 사용해서 프록시로 조회">지연 로딩 LAZY을 사용해서 프록시로 조회</a></li><li><a href=#%ec%a7%80%ec%97%b0-%eb%a1%9c%eb%94%a9 aria-label="지연 로딩">지연 로딩</a></li><li><a href=#%ec%a7%80%ec%97%b0-%eb%a1%9c%eb%94%a9-lazy%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%b4%ec%84%9c-%ed%94%84%eb%a1%9d%ec%8b%9c%eb%a1%9c-%ec%a1%b0%ed%9a%8c-1 aria-label="지연 로딩 LAZY을 사용해서 프록시로 조회">지연 로딩 LAZY을 사용해서 프록시로 조회</a></li><li><a href=#member%ec%99%80-team%ec%9d%84-%ec%9e%90%ec%a3%bc-%ed%95%a8%ea%bb%98-%ec%82%ac%ec%9a%a9%ed%95%9c%eb%8b%a4%eb%a9%b4 aria-label="Member와 Team을 자주 함께 사용한다면?">Member와 Team을 자주 함께 사용한다면?</a></li><li><a href=#%ec%a6%89%ec%8b%9c-%eb%a1%9c%eb%94%a9-eager%ec%9d%84-%ec%82%ac%ec%9a%a9%ed%95%b4%ec%84%9c-%ed%95%a8%ea%bb%98-%ec%a1%b0%ed%9a%8c aria-label="즉시 로딩 EAGER을 사용해서 함께 조회">즉시 로딩 EAGER을 사용해서 함께 조회</a></li><li><a href=#%ec%a6%89%ec%8b%9c-%eb%a1%9c%eb%94%a9 aria-label="즉시 로딩">즉시 로딩</a></li><li><a href=#%ec%a6%89%ec%8b%9c-%eb%a1%9c%eb%94%a9eager-member%ec%a1%b0%ed%9a%8c%ec%8b%9c-%ed%95%ad%ec%83%81-team%eb%8f%84-%ec%a1%b0%ed%9a%8c aria-label="즉시 로딩(EAGER), Member조회시 항상 Team도 조회">즉시 로딩(EAGER), Member조회시 항상 Team도 조회</a></li><li><a href=#%ed%94%84%eb%a1%9d%ec%8b%9c%ec%99%80-%ec%a6%89%ec%8b%9c%eb%a1%9c%eb%94%a9-%ec%a3%bc%ec%9d%98 aria-label="프록시와 즉시로딩 주의">프록시와 즉시로딩 주의</a></li></ul></li><li><a href=#%ec%a7%80%ec%97%b0-%eb%a1%9c%eb%94%a9-%ed%99%9c%ec%9a%a9 aria-label="지연 로딩 활용">지연 로딩 활용</a><ul><li><a href=#%ec%a7%80%ec%97%b0-%eb%a1%9c%eb%94%a9-%ed%99%9c%ec%9a%a9---%ec%8b%a4%eb%ac%b4 aria-label="지연 로딩 활용 - 실무">지연 로딩 활용 - 실무</a></li></ul></li><li><a href=#%ec%98%81%ec%86%8d%ec%84%b1-%ec%a0%84%ec%9d%b4-cascade aria-label="영속성 전이: CASCADE">영속성 전이: CASCADE</a><ul><li><a href=#%ec%98%81%ec%86%8d%ec%84%b1-%ec%a0%84%ec%9d%b4-%ec%a0%80%ec%9e%a5 aria-label="영속성 전이: 저장">영속성 전이: 저장</a></li><li><a href=#%ec%98%81%ec%86%8d%ec%84%b1-%ec%a0%84%ec%9d%b4-cascade---%ec%a3%bc%ec%9d%98 aria-label="영속성 전이: CASCADE - 주의!">영속성 전이: CASCADE - 주의!</a></li><li><a href=#cascade%ec%9d%98-%ec%a2%85%eb%a5%98 aria-label="CASCADE의 종류">CASCADE의 종류</a></li></ul></li><li><a href=#%ea%b3%a0%ec%95%84-%ea%b0%9d%ec%b2%b4 aria-label="고아 객체">고아 객체</a><ul><li><a href=#%ea%b3%a0%ec%95%84-%ea%b0%9d%ec%b2%b4---%ec%a3%bc%ec%9d%98 aria-label="고아 객체 - 주의">고아 객체 - 주의</a></li></ul></li><li><a href=#%ec%98%81%ec%86%8d%ec%84%b1-%ec%a0%84%ec%9d%b4--%ea%b3%a0%ec%95%84-%ea%b0%9d%ec%b2%b4-%ec%83%9d%eb%aa%85%ec%a3%bc%ea%b8%b0 aria-label="영속성 전이 + 고아 객체, 생명주기">영속성 전이 + 고아 객체, 생명주기</a></li><li><a href=#%ec%8b%a4%ec%a0%84-%ec%98%88%ec%a0%9c---5%ec%97%b0%ea%b4%80%ea%b4%80%ea%b3%84-%ea%b4%80%eb%a6%ac aria-label="실전 예제 - 5.연관관계 관리">실전 예제 - 5.연관관계 관리</a><ul><li><a href=#%ec%98%81%ec%86%8d%ec%84%b1-%ec%a0%84%ec%9d%b4-%ec%84%a4%ec%a0%95 aria-label="영속성 전이 설정">영속성 전이 설정</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>해당 글은 김영한님의 인프런 강의 <a href=https://www.inflearn.com/course/ORM-JPA-Basic>자바 ORM 표준 JPA 프로그래밍 - 기본편</a>을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.</p></blockquote><hr><h2 id=프록시>프록시<a hidden class=anchor aria-hidden=true href=#프록시>#</a></h2><h3 id=memer를-조회할-때-team도-함께-조회-해야-할까>Memer를 조회할 때 Team도 함께 조회 해야 할까?<a hidden class=anchor aria-hidden=true href=#memer를-조회할-때-team도-함께-조회-해야-할까>#</a></h3><p><img loading=lazy src=images/image.png alt=image.png></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>printUserAndTeam</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>memberId</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Member</span><span class=w> </span><span class=n>member</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>memberId</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Team</span><span class=w> </span><span class=n>team</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>member</span><span class=p>.</span><span class=na>getTeam</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;회원 이름: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>member</span><span class=p>.</span><span class=na>getUsername</span><span class=p>());</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;소속팀: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>team</span><span class=p>.</span><span class=na>getName</span><span class=p>());</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>회원과 팀 함께 출력</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>void</span><span class=w> </span><span class=nf>printUser</span><span class=p>(</span><span class=n>String</span><span class=w> </span><span class=n>memberId</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Member</span><span class=w> </span><span class=n>member</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>memberId</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Team</span><span class=w> </span><span class=n>team</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>member</span><span class=p>.</span><span class=na>getTeam</span><span class=p>();</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=s>&#34;회원 이름: &#34;</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=n>member</span><span class=p>.</span><span class=na>getUsername</span><span class=p>());</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>회원만 출력</li></ul><p>회원과 팀을 함께 출력하는 상황에서는 Member객체를 em.find()로 가져올때 Team도 DB에서 가져와서 괜찮은데 회원만 출력하고 싶을때는 Team의 정보까지 가져오기 때문에 최적화가 되지 않는다.</p><h3 id=프록시-기초>프록시 기초<a hidden class=anchor aria-hidden=true href=#프록시-기초>#</a></h3><ul><li>em.find() vs em.<strong>getReference()</strong></li><li>em.find(): 데이터베이스를 통해서 실제 엔티티 객체 조회</li><li>em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시)엔티티 객체 조회</li></ul><p><img loading=lazy src=images/image%201.png alt=image.png></p><p>em.find()를 사용하는 시점에는 select 쿼리를 DB에 날리고 진짜 객체를 받고 em.getReference()를 사용하는 시점에는 select 쿼리를 DB에 날리지 않고 가짜(프록시) 객체를 받는다. 그리고 member.getUsername()과 같은 Member객체의 필드값이 필요하면 select 쿼리를 DB에 날린다.</p><h3 id=프록시-특징>프록시 특징<a hidden class=anchor aria-hidden=true href=#프록시-특징>#</a></h3><ul><li>실제 클래스를 상속 받아서 만들어짐</li><li>실제 클래스와 겉 모양이 같다.</li><li>사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 됨 (이론상)</li></ul><p><img loading=lazy src=images/image%202.png alt=image.png></p><p><img loading=lazy src=images/image%203.png alt=image.png></p><ul><li>프록시 객체는 실제 객체의 참조(target)를 보관</li><li>프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드 호출</li></ul><h3 id=프록시-객체-초기화>프록시 객체 초기화<a hidden class=anchor aria-hidden=true href=#프록시-객체-초기화>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Member</span><span class=w> </span><span class=n>member</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>getReference</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=err>“</span><span class=n>id1</span><span class=err>”</span><span class=p>);</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>getName</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=images/image%204.png alt=image.png></p><p>em.getReferemce()로 프록시 객체를 가져오고 member.getName()을 가져와야하는데 Member target이 null 이기때문에 JPA가 영속성 컨텍스트에 Member 객체를 요청해서 영속성 컨텍스트가 DB를 조회해서 실제 엔티티객체를 생성하고 Member target에 연결해준다.
위 과정이 완료되고 target.getName()을 통해 실제 객체에서 값을 가져오온다.</p><h3 id=프록시의-특징>프록시의 특징<a hidden class=anchor aria-hidden=true href=#프록시의-특징>#</a></h3><ul><li>프록시 객체는 처음 사용할 때 한 번만 초기화</li><li>프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능</li><li>프록시 객체는 원본 엔티티를 상속받음, 따라서 <strong>타입 체크시 주의</strong>해야함 (== 비교 실패, 대신 <strong>instance of 사용</strong>)</li></ul><blockquote><p><details><summary markdown=span><strong>영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환</strong></summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Member</span><span class=w> </span><span class=n>m1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>calss</span><span class=p>,</span><span class=w> </span><span class=n>member1</span><span class=p>.</span><span class=na>getId</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;m1  =  {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>m1</span><span class=p>.</span><span class=na>getClass</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>reference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>getReference</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>member1</span><span class=p>.</span><span class=na>getId</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;reference = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=p>(</span><span class=n>m1</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>reference</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//log 결과</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>m1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>class</span> <span class=nc>hellojpa</span><span class=p>.</span><span class=na>Member</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>reference</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kd>class</span> <span class=nc>hellojpa</span><span class=p>.</span><span class=na>Member</span><span class=w>
</span></span></span></code></pre></div><p>위 결과 처럼 나오는 이유는 2가지 이유가 있다.
첫번째 이유는 Member를 영속성 컨텍스트에 올려놨는데 그걸 프록시로 가져와 봐야 아무 이점이 없고 원본을 반환하는게 성능 최적화 입장에서도 좋다.
두번째는 JPA에서는 같은 영속성 컨텍스트 안에서 == 비교를 TRUE로 보장해준다. 위 코드의 예시와 반대로 em.getReference()로 프록시 객체를 받고 em.find()를 요청해도 프록시 객체를 받는다.</p></details></p></blockquote><blockquote><p><details><summary markdown=span>영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생(하이버네이트는 org.hibernate.LazyInitializationException 예외를 터트림)</summary><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Member</span><span class=w> </span><span class=n>refMember</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>getReference</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>member1</span><span class=p>.</span><span class=na>getId</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//em.detech(refMember); 준영속 상태</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>clear</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>refMember</span><span class=p>.</span><span class=na>getUsername</span><span class=p>();</span><span class=w> </span><span class=c1>// org.hibernate.LazyInitializationException: could not initialize proxy 오류 발생</span><span class=w>
</span></span></span></code></pre></div></details></p></blockquote><h3 id=프록시-확인>프록시 확인<a hidden class=anchor aria-hidden=true href=#프록시-확인>#</a></h3><blockquote><p><details><summary markdown=span><strong>프록시 인스턴스의 초기화 여부 확인</strong></summary><p>PersistenceUnitUtil.isLoaded(Object entity)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>EntityManagerFactory</span><span class=w> </span><span class=n>emf</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Persistence</span><span class=p>.</span><span class=na>createEntityManagerFactory</span><span class=p>(...)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>refMember</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>getReference</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>classm</span><span class=w> </span><span class=n>member1</span><span class=p>.</span><span class=na>getId</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>log</span><span class=p>.</span><span class=na>info</span><span class=p>(</span><span class=s>&#34;isLoaded = {}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>emf</span><span class=p>.</span><span class=na>get</span><span class=w> </span><span class=nf>PersistenceUnitUtil</span><span class=p>().</span><span class=na>isLoaded</span><span class=p>(</span><span class=n>refMember</span><span class=p>)</span><span class=w> </span><span class=c1>// isLoaded = false가 나온다.</span><span class=w>
</span></span></span></code></pre></div></details></p></blockquote><ul><li><strong>프록시 클래스 확인 방법</strong>
entity.getClass().getName() 출력(..javasist.. orHibernateProxy…)</li></ul><blockquote><p><details><summary markdown=span><strong>프록시 강제 초기화</strong></summary><p>org.hibernate.Hibernate.initialize(entity);</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Member</span><span class=w> </span><span class=n>refMeber</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>getReference</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=n>member1</span><span class=p>.</span><span class=na>getId</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Hibernate</span><span class=p>.</span><span class=na>initialize</span><span class=p>(</span><span class=n>refMember</span><span class=p>);</span><span class=c1>//강제 초기화</span><span class=w>
</span></span></span></code></pre></div></details></p></blockquote><ul><li>참고: JPA 표준은 강제 초기화 없음
강제 호출: member.getName()</li></ul><hr><h2 id=즉시-로딩과-지연-로딩>즉시 로딩과 지연 로딩<a hidden class=anchor aria-hidden=true href=#즉시-로딩과-지연-로딩>#</a></h2><h3 id=member를-조회할-때-team도-함께-조회해야-할까>Member를 조회할 때 Team도 함께 조회해야 할까?<a hidden class=anchor aria-hidden=true href=#member를-조회할-때-team도-함께-조회해야-할까>#</a></h3><p>단순히 member 정보만 사용하는 비즈니스 로직
println(member.getName());</p><p><img loading=lazy src=images/image%205.png alt=image.png></p><p>단순히 Member를 조회할때 연관관계가 걸려있어서 Team까지 조인해서 가져오면 손해이기때문에 JPA는 지연 로딩이라는 옵션을 제공한다.</p><h3 id=지연-로딩-lazy을-사용해서-프록시로-조회>지연 로딩 LAZY을 사용해서 프록시로 조회<a hidden class=anchor aria-hidden=true href=#지연-로딩-lazy을-사용해서-프록시로-조회>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Member</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@Id</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@GeneratedValue</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@Column</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;USERNAME&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@ManyToOne</span><span class=p>(</span><span class=n>fetch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>FetchType</span><span class=p>.</span><span class=na>LAZY</span><span class=p>)</span><span class=w> </span><span class=c1>//** </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nd>@JoinColumn</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;TEAM_ID&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kd>private</span><span class=w> </span><span class=n>Team</span><span class=w> </span><span class=n>team</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>..</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>Member의 Team에 지연 로딩을 설정하면 em.find()로 member객체를 조회하고 Team객체는 프록시로 받는다.</p><h3 id=지연-로딩>지연 로딩<a hidden class=anchor aria-hidden=true href=#지연-로딩>#</a></h3><p><img loading=lazy src=images/image%206.png alt=image.png></p><h3 id=지연-로딩-lazy을-사용해서-프록시로-조회-1>지연 로딩 LAZY을 사용해서 프록시로 조회<a hidden class=anchor aria-hidden=true href=#지연-로딩-lazy을-사용해서-프록시로-조회-1>#</a></h3><p><img loading=lazy src=images/image%207.png alt=image.png></p><p>Member member = em.find(Member.class, 1L)</p><p><img loading=lazy src=images/image%208.png alt=image.png></p><p>Team team = member.getTeam();
team.getName(); //실제 team을 사용하는 시점에 초기화(DB 조회)</p><h3 id=member와-team을-자주-함께-사용한다면>Member와 Team을 자주 함께 사용한다면?<a hidden class=anchor aria-hidden=true href=#member와-team을-자주-함께-사용한다면>#</a></h3><p><img loading=lazy src=images/image%209.png alt=image.png></p><h3 id=즉시-로딩-eager을-사용해서-함께-조회>즉시 로딩 EAGER을 사용해서 함께 조회<a hidden class=anchor aria-hidden=true href=#즉시-로딩-eager을-사용해서-함께-조회>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Member</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Id</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GeneratedValue</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Column</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;USERNAME&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>name</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@ManyToOne</span><span class=p>(</span><span class=n>fetch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>FetchType</span><span class=p>.</span><span class=na>EAGER</span><span class=p>)</span><span class=w> </span><span class=c1>//** </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@JoinColumn</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;TEAM_ID&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Team</span><span class=w> </span><span class=n>team</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>..</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><h3 id=즉시-로딩>즉시 로딩<a hidden class=anchor aria-hidden=true href=#즉시-로딩>#</a></h3><p><img loading=lazy src=images/image%2010.png alt=image.png></p><p>Member를 조회할때 Team도 조인해서 값을 가져온다.</p><h3 id=즉시-로딩eager-member조회시-항상-team도-조회>즉시 로딩(EAGER), Member조회시 항상 Team도 조회<a hidden class=anchor aria-hidden=true href=#즉시-로딩eager-member조회시-항상-team도-조회>#</a></h3><p><img loading=lazy src=images/image%2011.png alt=image.png></p><p>JPA 구현체는 가능하면 조인을 사용해서 SQL 한번에 함께 조회</p><h3 id=프록시와-즉시로딩-주의>프록시와 즉시로딩 주의<a hidden class=anchor aria-hidden=true href=#프록시와-즉시로딩-주의>#</a></h3><ul><li><strong>가급적 지연 로딩만 사용(특히 실무에서)</strong></li><li>즉시 로딩을 적용하면 예상하지 못한 SQL이 발생</li><li><strong>즉시 로딩은 JPQL에서 N+1 문제를 일으킨다.</strong></li><li><strong>@ManyToOne, @OneToOne은 기본이 즉시 로딩 → LAZY로 설정</strong></li><li>@OneToMany, @ManyToMany는 기본이 지연 로딩</li></ul><hr><h2 id=지연-로딩-활용>지연 로딩 활용<a hidden class=anchor aria-hidden=true href=#지연-로딩-활용>#</a></h2><blockquote><p>실무에서는 모두 지연 로딩을 사용하는걸 권장</p></blockquote><ul><li><strong>Member</strong>와 <strong>Team</strong>은 자주 함께 사용 -> <strong>즉시 로딩</strong></li><li><strong>Member</strong>와 <strong>Order</strong>는 가끔 사용 -> <strong>지연 로딩</strong></li><li><strong>Order</strong>와 <strong>Product</strong>는 자주 함께 사용 -> <strong>즉시 로딩</strong></li></ul><p><img loading=lazy src=images/image%2012.png alt=image.png></p><p><img loading=lazy src=images/image%2013.png alt=image.png></p><p>Member를 조회하면 Team은 즉시 로디잉기때문에 member와 team의 쿼리가 한번에 나오고 orders는 지연 로딩이여서 프록시가 반한된다.</p><p><img loading=lazy src=images/image%2014.png alt=image.png></p><h3 id=지연-로딩-활용---실무>지연 로딩 활용 - 실무<a hidden class=anchor aria-hidden=true href=#지연-로딩-활용---실무>#</a></h3><ul><li><strong>모든 연관관계에 지연 로딩을 사용해라!</strong></li><li><strong>실무에서 즉시 로딩을 사용하지 마라!</strong></li><li>JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!
(뒤에서 설명)</li><li>즉시 로딩은 상상하지 못한 쿼리가 나간다.</li></ul><hr><h2 id=영속성-전이-cascade>영속성 전이: CASCADE<a hidden class=anchor aria-hidden=true href=#영속성-전이-cascade>#</a></h2><ul><li>특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속상태로 만들도 싶을 때</li><li>예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.</li></ul><p><img loading=lazy src=images/image%2015.png alt=image.png></p><h3 id=영속성-전이-저장>영속성 전이: 저장<a hidden class=anchor aria-hidden=true href=#영속성-전이-저장>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@OneToMany</span><span class=p>(</span><span class=n>mappedBy</span><span class=o>=</span><span class=s>&#34;parent&#34;</span><span class=p>,</span><span class=w> </span><span class=n>cascade</span><span class=o>=</span><span class=n>CascadeType</span><span class=p>.</span><span class=na>PERSIST</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Child</span><span class=w> </span><span class=n>child1</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Child</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Child</span><span class=w> </span><span class=n>child2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Child</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Parent</span><span class=w> </span><span class=n>parent</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Parent</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>parent</span><span class=p>.</span><span class=na>addChild</span><span class=p>(</span><span class=n>child1</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>parent</span><span class=p>.</span><span class=na>addChild</span><span class=p>(</span><span class=n>child2</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>parent</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//em.persist(child1);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//em.persist(child2);</span><span class=w>
</span></span></span></code></pre></div><p>parent 하나만 persist했는데 child1, child2 둘다 persist가 된다. 만약 cascade=CascadeType.PERSIST하지 않고 parent만 persist하면 오류가 난다.</p><p><img loading=lazy src=images/image%2016.png alt=image.png></p><h3 id=영속성-전이-cascade---주의>영속성 전이: CASCADE - 주의!<a hidden class=anchor aria-hidden=true href=#영속성-전이-cascade---주의>#</a></h3><ul><li>영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음</li><li>엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐</li></ul><h3 id=cascade의-종류>CASCADE의 종류<a hidden class=anchor aria-hidden=true href=#cascade의-종류>#</a></h3><ul><li><strong>ALL: 모두 적용</strong></li><li><strong>PERSIST: 영속</strong></li><li><strong>REMOVE: 삭제</strong></li><li>MERGE: 병합</li><li>REFRESH: REFRESH</li><li>DETACH: DETACH</li></ul><p>쓸만한 것은 All, Persist인데 저장만 할때와 삭제하면 안되고 조심해야할때는 Persist쓰고 라이프사이클을 다 맞춰야 하면 All을 쓰면 된다.
그리고 소유자가 한명일때와 라이프사이클이 같을때만 사용한다.</p><hr><h2 id=고아-객체>고아 객체<a hidden class=anchor aria-hidden=true href=#고아-객체>#</a></h2><ul><li>고아 객체 제거: 부모 엔티티와 연관관계가 끊어진 자식엔티티를 자동으로 삭제</li><li><strong>orphanRemoval = true</strong></li><li>Parent parent1 = em.find(Parent.class, id);
parent1.getChildren().remove(0);
//자식 엔티티를 컬렉션에서 제거</li><li>DELETE FROM CHILD WHERE ID=?</li></ul><h3 id=고아-객체---주의>고아 객체 - 주의<a hidden class=anchor aria-hidden=true href=#고아-객체---주의>#</a></h3><ul><li>참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로보고 삭제하는 기능</li><li><strong>참조하는 곳이 하나일 때 사용해야함</strong>!</li><li><strong>특정 엔티티가 개인 소유할 때 사용</strong></li><li>@OneToOne, @OneToMany만 가능</li><li>참고: 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께제거된다. 이것은 CascadeType.REMOVE처럼 동작한다.</li></ul><hr><h2 id=영속성-전이--고아-객체-생명주기>영속성 전이 + 고아 객체, 생명주기<a hidden class=anchor aria-hidden=true href=#영속성-전이--고아-객체-생명주기>#</a></h2><ul><li><strong>CascadeType.ALL + orphanRemoval=true</strong></li><li>스스로 생명주기를 관리하는 엔티티는 em.persist()로 영속화, em.remove()로 제거</li><li>두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있음</li><li>도메인 주도 설계(DDD)의 Aggregate Root개념을 구현할 때 유용</li></ul><hr><h2 id=실전-예제---5연관관계-관리>실전 예제 - 5.연관관계 관리<a hidden class=anchor aria-hidden=true href=#실전-예제---5연관관계-관리>#</a></h2><ul><li>모든 연관관계를 지연 로딩으로</li><li>@ManyToOne, @OneToOne은 기본이 즉시 로딩이므로 지연 로딩으로 변경</li></ul><h3 id=영속성-전이-설정>영속성 전이 설정<a hidden class=anchor aria-hidden=true href=#영속성-전이-설정>#</a></h3><ul><li><strong>Order</strong> -> <strong>Delivery</strong>를 영속성 전이 ALL 설정</li><li><strong>Order</strong> -> <strong>OrderItem</strong>을 영속성 전이 ALL 설정</li></ul><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://yosong6729.github.io/tags/jpa/>JPA</a></li></ul><nav class=paginav><a class=next href=https://yosong6729.github.io/post/%EA%B3%A0%EA%B8%89-%EB%A7%A4%ED%95%91/><span class=title>Next »</span><br><span>[자바 ORM 표준 JPA 프로그래밍 - 기본편] 고급 매핑</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yosong6729.github.io/>Yosong6729 Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>