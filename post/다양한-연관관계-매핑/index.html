<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[자바 ORM 표준 JPA 프로그래밍 - 기본편] 다양한 연관관계 매핑 | Yosong6729 Blog</title>
<meta name=keywords content="JPA"><meta name=description content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
연관관계 매핑시 고려사항 3가지 다중성 단방향, 양방향 연관관계의 주인 다중성 다대일: @ManyToOne 일대다: @OneToMany 일대일: @OneToOne 다대다: @ManyToMany 단방향, 양방향 테이블 외래 키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 연관관계의 주인 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음."><meta name=author content="yosong6729"><link rel=canonical href=https://yosong6729.github.io/post/%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yosong6729.github.io/post/%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="[자바 ORM 표준 JPA 프로그래밍 - 기본편] 다양한 연관관계 매핑"><meta property="og:description" content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
연관관계 매핑시 고려사항 3가지 다중성 단방향, 양방향 연관관계의 주인 다중성 다대일: @ManyToOne 일대다: @OneToMany 일대일: @OneToOne 다대다: @ManyToMany 단방향, 양방향 테이블 외래 키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 연관관계의 주인 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음."><meta property="og:type" content="article"><meta property="og:url" content="https://yosong6729.github.io/post/%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"><meta property="og:image" content="https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-12T15:50:55+09:00"><meta property="article:modified_time" content="2024-09-12T15:50:55+09:00"><meta property="og:site_name" content="Yosong6729 Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[자바 ORM 표준 JPA 프로그래밍 - 기본편] 다양한 연관관계 매핑"><meta name=twitter:description content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
연관관계 매핑시 고려사항 3가지 다중성 단방향, 양방향 연관관계의 주인 다중성 다대일: @ManyToOne 일대다: @OneToMany 일대일: @OneToOne 다대다: @ManyToMany 단방향, 양방향 테이블 외래 키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 연관관계의 주인 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yosong6729.github.io/post/"},{"@type":"ListItem","position":2,"name":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 다양한 연관관계 매핑","item":"https://yosong6729.github.io/post/%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 다양한 연관관계 매핑","name":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 다양한 연관관계 매핑","description":"해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.\n연관관계 매핑시 고려사항 3가지 다중성 단방향, 양방향 연관관계의 주인 다중성 다대일: @ManyToOne 일대다: @OneToMany 일대일: @OneToOne 다대다: @ManyToMany 단방향, 양방향 테이블 외래 키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 연관관계의 주인 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A-\u0026gt;B, B-\u0026gt;A 처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음.","keywords":["JPA"],"articleBody":"해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.\n연관관계 매핑시 고려사항 3가지 다중성 단방향, 양방향 연관관계의 주인 다중성 다대일: @ManyToOne 일대다: @OneToMany 일대일: @OneToOne 다대다: @ManyToMany 단방향, 양방향 테이블 외래 키 하나로 양쪽 조인 가능 사실 방향이라는 개념이 없음 객체 참조용 필드가 있는 쪽으로만 참조 가능 한쪽만 참조하면 단방향 양쪽이 서로 참조하면 양방향 연관관계의 주인 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음 객체 양방향 관계는 A-\u003eB, B-\u003eA 처럼 참조가 2군데 객체 양방향 관계는 참조가 2군데 있음. 둘중 테이블의 외래 키를 관리할 곳을 지정해야함 연관관계의 주인: 외래 키를 관리하는 참조 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능 다대일 [N:1] 다대일 단방향 외래키가 있는곳에 참조를 걸고 연관관계 매핑을 하는것이 다대일 단방향 매핑이다.\n다대일 단방향 정리 가장 많이 사용하는 연관관꼐 다대일의 반대는 일대다 다대일 양방향 다대일 양방향은 반대쪽에 List members를 추가하면 된다. 반대쪽에 추가해도 테이블에는 영향이 가지 않는다.\n지금 부터 무슨대무슨 무슨방향 에서 앞에 나오는( ex)”다”대일 양방향 에서 “다”)것은 연관관계의 주인이다.\n다대일 양방향 정리 외래 키가 있는 쪽이 연관관계의 주인 양쪽을 서로 참조하도록 개발 일대다 [1:N] 일대다 단방향 일이 연관관계의 주인이다. 이 모델은 권장하지 않는다.\n객체 입장에서는 위 사진처럼 List members가 연관관계의 주인으로 설계 될수 있다. 하지만 DB 입장 Member의 TEAM_ID가 연관관계의 주인이 될수 밖에 없다.\n일다대 단방향 정리 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인 테이블 일대다 관계는 항상 다(N) 쪽에 외래 키가 있음 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조 @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함) 일대다 단방향 매핑의 단점 엔티티가 관리하는 외래 키가 다른 테이블에 있음 연관관계 관리를 위해 추가로 UPDATE SQL 실행 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자 일대다 양방향 일대다 양방향 정리 이런 매핑은 공식적으로 존재X @JoinColumn(insertable=false, updatable=false) 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 다대일 양방향을 사용하자 일대일 [1:1] 일대일 관계 일대일 관계는 그 반대도 일대일 주 테이블이나 대상 테이블 중에 외래 키 선택 가능 주 테이블에 외래 키 대상 테이블에 외래 키 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가 일대일: 주 테이블에 외래 키 단방향 Member가 하나의 Locker(사물함)을 가지는 상황\nMember 테이블에 LOCKER_ID가 FK이면 Member 객체의 Locker locker을 추가해서 연관관계 매핑을 해주면 된다.\n일대일: 주 테이블에 외래 키 단방향 정리 다대일(@ManyToOne) 단방향 매핑과 유사 일대일: 주 테이블에 외래 키 양방향 양방향을 하려면 반대쪽(Locker)에 Member member를 추가해서 mappedby를 추가해주면 된다.\n일대일: 주 테이블에 외래 키 양방향 정리 다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인 반대편은 mappedBy 적용 일대일: 대상 테이블에 외래키 단방향 일대일: 대상 테이블에 외래 키 단방향 정리 단방향 관계는 JPA 지원X 양방향 관계는 지원 일대일: 대상 테이블에 외래 키 양방향 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같다.\n일대일 정리 주 테이블에 외래 키 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음 객체지향 개발자 선호 JPA 매핑 편리 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능 단점: 값이 없으면 외래 키에 null 허용 대상 테이블에 외래 키 대상 테이블에 외래 키가 존재 전통적인 데이터베이스 개발자 선호 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명) 다대다 [N:M] 다대다 결론부터 말하자면 실무에서 쓰면 안된다.\n관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함 객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능\n@ManyToMany 사용 @JoinTable로 연결 테이블 지정 다대다 매핑: 단방향, 양방향 가능 다대다 매핑의 한계 편리해 보이지만 실무에서 사용X 연결 테이블이 단순히 연결만 하고 끝나지 않음 주문시간, 수량 같은 데이터가 들어올 수 있음 중간에 데이터를 추가하게 된다면 추가하지 못하게 된다.\n다대다 한계 극복 연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격) @ManyToMany -\u003e @OneToMany, @ManyToOne Member와 Product를 연결해줄 MemberProduct 엔티티를 추가하면 된다. 그러면 MemberProcut 엔티티에 주문시간, 수량 같은 데이터 들이 중간에 들어올수 있다.\n실전 예제 - 3.다양한 연관관계 매핑 실전 예제의 코드는 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편에서 확인하실수 있습니다.\n주문과 배송은 1:1(@OneToOne) 상품과 카테고리는 N:M(@ManyToMany) 배송, 카테고리 추가 - ERD 배송, 카테고리 추가 - 엔티티 상세 N:M 관계는 1:N, N:1로 테이블의 N:M 관계는 중간 테이블을 이용해서 1:N, N:1 실전에서는 중간 테이블이 단순하지 않다. @ManyToMany는 제약: 필드 추가X, 엔티티 테이블 불일치 실전에서는 @ManyToMany 사용X @JoinColumn 속성 설명 기본값 name 매핑할 외래 키 이름 필드명 + _ + 참조하는 테이블의 기본 키 컬럼명 referencedColumnName 외래 키가 참조하는 대상 테이블의 컬럼명 참조하는 테이블의 기본키 컬럼명 foreignKey(DDL) 외래 키 제약조건을 직접 지정할 수 있다.이 속성은 테이블을 생성할 때만 사용한다. unique\nnullable insertable\nupdatable\ncolumnDefinition\ntable @Column의 속성과 같다. @ManyToOne - 주요 속성 다대일 관계 매핑\n속성 설명 기본값 optional false로 설정하면 연관된 엔티티가 항상 있어야 한다. TRUE fetch 글로벌 페치 전략을 설정한다. @ManyToOne=FetchType.EAGER\n@OneToMany=FetchType.LAZY cascade 영속성 전이 기능을 사용한다. targetEntity 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다. @OneToMany - 주요 속성 일대다 관계 매핑\n속성 설명 기본값 mappedBy 연관관계의 주인 필드를 선택한다. fetch 글로벌 페치 전략을 설정한다. @ManyToOne=FetchType.EAGER @OneToMany=FetchType.LAZY cascade 영속성 전이 기능을 사용한다. targetEntity 연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다 ","wordCount":"838","inLanguage":"en","image":"https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-12T15:50:55+09:00","dateModified":"2024-09-12T15:50:55+09:00","author":{"@type":"Person","name":"yosong6729"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yosong6729.github.io/post/%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/"},"publisher":{"@type":"Organization","name":"Yosong6729 Blog","logo":{"@type":"ImageObject","url":"https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yosong6729.github.io/ accesskey=h title="Yosong6729 블로그 (Alt + H)"><img src=https://yosong6729.github.io/apple-touch-icon.png alt aria-label=logo height=35>Yosong6729 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yosong6729.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://yosong6729.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yosong6729.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yosong6729.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">[자바 ORM 표준 JPA 프로그래밍 - 기본편] 다양한 연관관계 매핑</h1><div class=post-meta><span title='2024-09-12 15:50:55 +0900 KST'>September 12, 2024</span>&nbsp;·&nbsp;yosong6729&nbsp;|&nbsp;<a href=https://github.com/yosong6729/blog/tree/main/content/post/%eb%8b%a4%ec%96%91%ed%95%9c%20%ec%97%b0%ea%b4%80%ea%b4%80%ea%b3%84%20%eb%a7%a4%ed%95%91/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%97%b0%ea%b4%80%ea%b4%80%ea%b3%84-%eb%a7%a4%ed%95%91%ec%8b%9c-%ea%b3%a0%eb%a0%a4%ec%82%ac%ed%95%ad-3%ea%b0%80%ec%a7%80 aria-label="연관관계 매핑시 고려사항 3가지">연관관계 매핑시 고려사항 3가지</a><ul><li><a href=#%eb%8b%a4%ec%a4%91%ec%84%b1 aria-label=다중성>다중성</a></li></ul></li><li><a href=#%eb%8b%a8%eb%b0%a9%ed%96%a5-%ec%96%91%eb%b0%a9%ed%96%a5 aria-label="단방향, 양방향">단방향, 양방향</a><ul><li><a href=#%ec%97%b0%ea%b4%80%ea%b4%80%ea%b3%84%ec%9d%98-%ec%a3%bc%ec%9d%b8 aria-label="연관관계의 주인">연관관계의 주인</a></li></ul></li><li><a href=#%eb%8b%a4%eb%8c%80%ec%9d%bc-n1 aria-label="다대일 [N:1]">다대일 [N:1]</a><ul><li><a href=#%eb%8b%a4%eb%8c%80%ec%9d%bc-%eb%8b%a8%eb%b0%a9%ed%96%a5 aria-label="다대일 단방향">다대일 단방향</a></li><li><a href=#%eb%8b%a4%eb%8c%80%ec%9d%bc-%eb%8b%a8%eb%b0%a9%ed%96%a5-%ec%a0%95%eb%a6%ac aria-label="다대일 단방향 정리">다대일 단방향 정리</a></li><li><a href=#%eb%8b%a4%eb%8c%80%ec%9d%bc-%ec%96%91%eb%b0%a9%ed%96%a5 aria-label="다대일 양방향">다대일 양방향</a></li><li><a href=#%eb%8b%a4%eb%8c%80%ec%9d%bc-%ec%96%91%eb%b0%a9%ed%96%a5-%ec%a0%95%eb%a6%ac aria-label="다대일 양방향 정리">다대일 양방향 정리</a></li></ul></li><li><a href=#%ec%9d%bc%eb%8c%80%eb%8b%a4-1n aria-label="일대다 [1:N]">일대다 [1:N]</a><ul><li><a href=#%ec%9d%bc%eb%8c%80%eb%8b%a4-%eb%8b%a8%eb%b0%a9%ed%96%a5 aria-label="일대다 단방향">일대다 단방향</a></li><li><a href=#%ec%9d%bc%eb%8b%a4%eb%8c%80-%eb%8b%a8%eb%b0%a9%ed%96%a5-%ec%a0%95%eb%a6%ac aria-label="일다대 단방향 정리">일다대 단방향 정리</a></li><li><a href=#%ec%9d%bc%eb%8c%80%eb%8b%a4-%ec%96%91%eb%b0%a9%ed%96%a5 aria-label="일대다 양방향">일대다 양방향</a></li><li><a href=#%ec%9d%bc%eb%8c%80%eb%8b%a4-%ec%96%91%eb%b0%a9%ed%96%a5-%ec%a0%95%eb%a6%ac aria-label="일대다 양방향 정리">일대다 양방향 정리</a></li></ul></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-11 aria-label="일대일 [1:1]">일대일 [1:1]</a><ul><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%ea%b4%80%ea%b3%84 aria-label="일대일 관계">일대일 관계</a></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%ec%a3%bc-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90-%ec%99%b8%eb%9e%98-%ed%82%a4-%eb%8b%a8%eb%b0%a9%ed%96%a5 aria-label="일대일: 주 테이블에 외래 키 단방향">일대일: 주 테이블에 외래 키 단방향</a></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%ec%a3%bc-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90-%ec%99%b8%eb%9e%98-%ed%82%a4-%eb%8b%a8%eb%b0%a9%ed%96%a5-%ec%a0%95%eb%a6%ac aria-label="일대일: 주 테이블에 외래 키 단방향 정리">일대일: 주 테이블에 외래 키 단방향 정리</a></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%ec%a3%bc-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90-%ec%99%b8%eb%9e%98-%ed%82%a4-%ec%96%91%eb%b0%a9%ed%96%a5 aria-label="일대일: 주 테이블에 외래 키 양방향">일대일: 주 테이블에 외래 키 양방향</a></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%ec%a3%bc-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90-%ec%99%b8%eb%9e%98-%ed%82%a4-%ec%96%91%eb%b0%a9%ed%96%a5-%ec%a0%95%eb%a6%ac aria-label="일대일: 주 테이블에 외래 키 양방향 정리">일대일: 주 테이블에 외래 키 양방향 정리</a></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%eb%8c%80%ec%83%81-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90-%ec%99%b8%eb%9e%98%ed%82%a4-%eb%8b%a8%eb%b0%a9%ed%96%a5 aria-label="일대일: 대상 테이블에 외래키 단방향">일대일: 대상 테이블에 외래키 단방향</a></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%eb%8c%80%ec%83%81-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90-%ec%99%b8%eb%9e%98-%ed%82%a4-%eb%8b%a8%eb%b0%a9%ed%96%a5-%ec%a0%95%eb%a6%ac aria-label="일대일: 대상 테이블에 외래 키 단방향 정리">일대일: 대상 테이블에 외래 키 단방향 정리</a></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%eb%8c%80%ec%83%81-%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90-%ec%99%b8%eb%9e%98-%ed%82%a4-%ec%96%91%eb%b0%a9%ed%96%a5 aria-label="일대일: 대상 테이블에 외래 키 양방향">일대일: 대상 테이블에 외래 키 양방향</a></li><li><a href=#%ec%9d%bc%eb%8c%80%ec%9d%bc-%ec%a0%95%eb%a6%ac aria-label="일대일 정리">일대일 정리</a></li></ul></li><li><a href=#%eb%8b%a4%eb%8c%80%eb%8b%a4-nm aria-label="다대다 [N:M]">다대다 [N:M]</a><ul><li><a href=#%eb%8b%a4%eb%8c%80%eb%8b%a4 aria-label=다대다>다대다</a></li><li><a href=#%eb%8b%a4%eb%8c%80%eb%8b%a4-%eb%a7%a4%ed%95%91%ec%9d%98-%ed%95%9c%ea%b3%84 aria-label="다대다 매핑의 한계">다대다 매핑의 한계</a></li><li><a href=#%eb%8b%a4%eb%8c%80%eb%8b%a4-%ed%95%9c%ea%b3%84-%ea%b7%b9%eb%b3%b5 aria-label="다대다 한계 극복">다대다 한계 극복</a></li></ul></li><li><a href=#%ec%8b%a4%ec%a0%84-%ec%98%88%ec%a0%9c---3%eb%8b%a4%ec%96%91%ed%95%9c-%ec%97%b0%ea%b4%80%ea%b4%80%ea%b3%84-%eb%a7%a4%ed%95%91 aria-label="실전 예제 - 3.다양한 연관관계 매핑">실전 예제 - 3.다양한 연관관계 매핑</a><ul><li><a href=#%eb%b0%b0%ec%86%a1-%ec%b9%b4%ed%85%8c%ea%b3%a0%eb%a6%ac-%ec%b6%94%ea%b0%80---erd aria-label="배송, 카테고리 추가 - ERD">배송, 카테고리 추가 - ERD</a></li><li><a href=#%eb%b0%b0%ec%86%a1-%ec%b9%b4%ed%85%8c%ea%b3%a0%eb%a6%ac-%ec%b6%94%ea%b0%80---%ec%97%94%ed%8b%b0%ed%8b%b0-%ec%83%81%ec%84%b8 aria-label="배송, 카테고리 추가 - 엔티티 상세">배송, 카테고리 추가 - 엔티티 상세</a></li><li><a href=#nm-%ea%b4%80%ea%b3%84%eb%8a%94-1n-n1%eb%a1%9c aria-label="N:M 관계는 1:N, N:1로">N:M 관계는 1:N, N:1로</a></li><li><a href=#joincolumn aria-label=@JoinColumn>@JoinColumn</a></li><li><a href=#manytoone---%ec%a3%bc%ec%9a%94-%ec%86%8d%ec%84%b1 aria-label="@ManyToOne - 주요 속성">@ManyToOne - 주요 속성</a></li><li><a href=#onetomany---%ec%a3%bc%ec%9a%94-%ec%86%8d%ec%84%b1 aria-label="@OneToMany - 주요 속성">@OneToMany - 주요 속성</a></li></ul></li></ul></div></details></div><div class=post-content><p>해당 글은 김영한님의 인프런 강의 <a href=https://www.inflearn.com/course/ORM-JPA-Basic>자바 ORM 표준 JPA 프로그래밍 - 기본편</a>을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.</p><hr><h2 id=연관관계-매핑시-고려사항-3가지>연관관계 매핑시 고려사항 3가지<a hidden class=anchor aria-hidden=true href=#연관관계-매핑시-고려사항-3가지>#</a></h2><ul><li>다중성</li><li>단방향, 양방향</li><li>연관관계의 주인</li></ul><h3 id=다중성>다중성<a hidden class=anchor aria-hidden=true href=#다중성>#</a></h3><ul><li>다대일: @ManyToOne</li><li>일대다: @OneToMany</li><li>일대일: @OneToOne</li><li>다대다: @ManyToMany</li></ul><h2 id=단방향-양방향>단방향, 양방향<a hidden class=anchor aria-hidden=true href=#단방향-양방향>#</a></h2><ul><li><strong>테이블</strong><ul><li>외래 키 하나로 양쪽 조인 가능</li><li>사실 방향이라는 개념이 없음</li></ul></li><li><strong>객체</strong><ul><li>참조용 필드가 있는 쪽으로만 참조 가능</li><li>한쪽만 참조하면 단방향</li><li>양쪽이 서로 참조하면 양방향</li></ul></li></ul><h3 id=연관관계의-주인>연관관계의 주인<a hidden class=anchor aria-hidden=true href=#연관관계의-주인>#</a></h3><ul><li>테이블은 <strong>외래 키 하나</strong>로 두 테이블이 연관관계를 맺음</li><li>객체 양방향 관계는 A->B, B->A 처럼 <strong>참조가 2군데</strong></li><li>객체 양방향 관계는 참조가 2군데 있음. 둘중 테이블의 외래 키를 관리할 곳을 지정해야함</li><li>연관관계의 주인: 외래 키를 관리하는 참조</li><li>주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능</li></ul><hr><h2 id=다대일-n1>다대일 [N:1]<a hidden class=anchor aria-hidden=true href=#다대일-n1>#</a></h2><h3 id=다대일-단방향>다대일 단방향<a hidden class=anchor aria-hidden=true href=#다대일-단방향>#</a></h3><p><img loading=lazy src=images/%eb%8b%a4%eb%8c%80%ec%9d%bc%20%eb%8b%a8%eb%b0%a9%ed%96%a5.png alt=image.png></p><p>외래키가 있는곳에 참조를 걸고 연관관계 매핑을 하는것이 다대일 단방향 매핑이다.</p><h3 id=다대일-단방향-정리>다대일 단방향 정리<a hidden class=anchor aria-hidden=true href=#다대일-단방향-정리>#</a></h3><ul><li>가장 많이 사용하는 연관관꼐</li><li><strong>다대일</strong>의 반대는 <strong>일대다</strong></li></ul><h3 id=다대일-양방향>다대일 양방향<a hidden class=anchor aria-hidden=true href=#다대일-양방향>#</a></h3><p><img loading=lazy src=images/%eb%8b%a4%eb%8c%80%ec%9d%bc%20%ec%96%91%eb%b0%a9%ed%96%a5.png alt=image.png></p><p>다대일 양방향은 반대쪽에 List members를 추가하면 된다.
반대쪽에 추가해도 테이블에는 영향이 가지 않는다.</p><blockquote><p>지금 부터 무슨대무슨 무슨방향 에서 앞에 나오는( ex)”다”대일 양방향 에서 “다”)것은 연관관계의 주인이다.</p></blockquote><h3 id=다대일-양방향-정리>다대일 양방향 정리<a hidden class=anchor aria-hidden=true href=#다대일-양방향-정리>#</a></h3><ul><li>외래 키가 있는 쪽이 연관관계의 주인</li><li>양쪽을 서로 참조하도록 개발</li></ul><hr><h2 id=일대다-1n>일대다 [1:N]<a hidden class=anchor aria-hidden=true href=#일대다-1n>#</a></h2><h3 id=일대다-단방향>일대다 단방향<a hidden class=anchor aria-hidden=true href=#일대다-단방향>#</a></h3><p><img loading=lazy src=images/%ec%9d%bc%eb%8c%80%eb%8b%a4%20%eb%8b%a8%eb%b0%a9%ed%96%a5.png alt=image.png></p><blockquote><p>일이 연관관계의 주인이다.
이 모델은 권장하지 않는다.</p></blockquote><p>객체 입장에서는 위 사진처럼 List members가 연관관계의 주인으로 설계 될수 있다. 하지만 DB 입장 Member의 TEAM_ID가 연관관계의 주인이 될수 밖에 없다.</p><h3 id=일다대-단방향-정리>일다대 단방향 정리<a hidden class=anchor aria-hidden=true href=#일다대-단방향-정리>#</a></h3><ul><li>일대다 단방향은 일대다(1:N)에서 <strong>일(1)이 연관관계의 주인</strong></li><li>테이블 일대다 관계는 항상 <strong>다(N) 쪽에 외래 키가 있음</strong></li><li>객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조</li><li>@JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함)</li><li>일대다 단방향 매핑의 단점<ul><li>엔티티가 관리하는 외래 키가 다른 테이블에 있음</li><li>연관관계 관리를 위해 추가로 UPDATE SQL 실행</li></ul></li><li>일대다 단방향 매핑보다는 <strong>다대일 양방향 매핑을 사용</strong>하자</li></ul><h3 id=일대다-양방향>일대다 양방향<a hidden class=anchor aria-hidden=true href=#일대다-양방향>#</a></h3><p><img loading=lazy src=images/%ec%9d%bc%eb%8c%80%eb%8b%a4%20%ec%96%91%eb%b0%a9%ed%96%a5.png alt=image.png></p><h3 id=일대다-양방향-정리>일대다 양방향 정리<a hidden class=anchor aria-hidden=true href=#일대다-양방향-정리>#</a></h3><ul><li>이런 매핑은 공식적으로 존재X</li><li>@JoinColumn(<strong>insertable=false, updatable=false</strong>)</li><li><strong>읽기 전용 필드</strong>를 사용해서 양방향 처럼 사용하는 방법</li><li><strong>다대일 양방향을 사용하자</strong></li></ul><hr><h2 id=일대일-11>일대일 [1:1]<a hidden class=anchor aria-hidden=true href=#일대일-11>#</a></h2><h3 id=일대일-관계>일대일 관계<a hidden class=anchor aria-hidden=true href=#일대일-관계>#</a></h3><ul><li><strong>일대일</strong> 관계는 그 반대도 <strong>일대일</strong></li><li>주 테이블이나 대상 테이블 중에 외래 키 선택 가능<ul><li>주 테이블에 외래 키</li><li>대상 테이블에 외래 키</li></ul></li><li>외래 키에 데이터베이스 <strong>유니크(UNI) 제약조건 추가</strong></li></ul><h3 id=일대일-주-테이블에-외래-키-단방향>일대일: 주 테이블에 외래 키 단방향<a hidden class=anchor aria-hidden=true href=#일대일-주-테이블에-외래-키-단방향>#</a></h3><p><img loading=lazy src=images/%ec%9d%bc%eb%8c%80%ec%9d%bc%20%ec%a3%bc%20%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90%20%ec%99%b8%eb%9e%98%20%ed%82%a4%20%eb%8b%a8%eb%b0%a9%ed%96%a5.png alt=image.png></p><p>Member가 하나의 Locker(사물함)을 가지는 상황</p><p>Member 테이블에 LOCKER_ID가 FK이면 Member 객체의 Locker locker을 추가해서 연관관계 매핑을 해주면 된다.</p><h3 id=일대일-주-테이블에-외래-키-단방향-정리>일대일: 주 테이블에 외래 키 단방향 정리<a hidden class=anchor aria-hidden=true href=#일대일-주-테이블에-외래-키-단방향-정리>#</a></h3><ul><li>다대일(@ManyToOne) 단방향 매핑과 유사</li></ul><h3 id=일대일-주-테이블에-외래-키-양방향>일대일: 주 테이블에 외래 키 양방향<a hidden class=anchor aria-hidden=true href=#일대일-주-테이블에-외래-키-양방향>#</a></h3><p><img loading=lazy src=images/%ec%9d%bc%eb%8c%80%ec%9d%bc%20%ec%a3%bc%20%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90%20%ec%99%b8%eb%9e%98%20%ed%82%a4%20%ec%96%91%eb%b0%a9%ed%96%a5.png alt=image.png></p><p>양방향을 하려면 반대쪽(Locker)에 Member member를 추가해서 mappedby를 추가해주면 된다.</p><h3 id=일대일-주-테이블에-외래-키-양방향-정리>일대일: 주 테이블에 외래 키 양방향 정리<a hidden class=anchor aria-hidden=true href=#일대일-주-테이블에-외래-키-양방향-정리>#</a></h3><ul><li>다대일 양방향 매핑 처럼 <strong>외래 키가 있는 곳이 연관관계의 주인</strong></li><li>반대편은 mappedBy 적용</li></ul><h3 id=일대일-대상-테이블에-외래키-단방향>일대일: 대상 테이블에 외래키 단방향<a hidden class=anchor aria-hidden=true href=#일대일-대상-테이블에-외래키-단방향>#</a></h3><p><img loading=lazy src=images/%ec%9d%bc%eb%8c%80%ec%9d%bc%20%eb%8c%80%ec%83%81%20%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90%20%ec%99%b8%eb%9e%98%ed%82%a4%20%eb%8b%a8%eb%b0%a9%ed%96%a5.png alt=image.png></p><h3 id=일대일-대상-테이블에-외래-키-단방향-정리>일대일: 대상 테이블에 외래 키 단방향 정리<a hidden class=anchor aria-hidden=true href=#일대일-대상-테이블에-외래-키-단방향-정리>#</a></h3><ul><li><strong>단방향 관계는 JPA 지원X</strong></li><li>양방향 관계는 지원</li></ul><h3 id=일대일-대상-테이블에-외래-키-양방향>일대일: 대상 테이블에 외래 키 양방향<a hidden class=anchor aria-hidden=true href=#일대일-대상-테이블에-외래-키-양방향>#</a></h3><p><img loading=lazy src=images/%ec%9d%bc%eb%8c%80%ec%9d%bc%20%eb%8c%80%ec%83%81%20%ed%85%8c%ec%9d%b4%eb%b8%94%ec%97%90%20%ec%99%b8%eb%9e%98%20%ed%82%a4%20%ec%96%91%eb%b0%a9%ed%96%a5.png alt=image.png></p><p>일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같다.</p><h3 id=일대일-정리>일대일 정리<a hidden class=anchor aria-hidden=true href=#일대일-정리>#</a></h3><ul><li><strong>주 테이블에 외래 키</strong><ul><li>주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음</li><li>객체지향 개발자 선호</li><li>JPA 매핑 편리</li><li>장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능</li><li>단점: 값이 없으면 외래 키에 null 허용</li></ul></li><li><strong>대상 테이블에 외래 키</strong><ul><li>대상 테이블에 외래 키가 존재</li><li>전통적인 데이터베이스 개발자 선호</li><li>장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지</li><li>단점: 프록시 기능의 한계로 <strong>지연 로딩으로 설정해도 항상 즉시 로딩됨</strong>(프록시는 뒤에서 설명)</li></ul></li></ul><hr><h2 id=다대다-nm>다대다 [N:M]<a hidden class=anchor aria-hidden=true href=#다대다-nm>#</a></h2><h3 id=다대다>다대다<a hidden class=anchor aria-hidden=true href=#다대다>#</a></h3><blockquote><p>결론부터 말하자면 실무에서 쓰면 안된다.</p></blockquote><ul><li>관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음</li><li>연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함</li></ul><p><img loading=lazy src=images/%eb%8b%a4%eb%8c%80%eb%8b%a4.png alt=image.png></p><p><strong>객체는 컬렉션을 사용해서 객체 2개로 다대다 관계 가능</strong></p><p><img loading=lazy src=images/%ea%b0%9d%ec%b2%b4%202%ea%b0%9c%eb%a1%9c%20%eb%8b%a4%eb%8c%80%eb%8b%a4%20%ea%b4%80%ea%b3%84%20%ea%b0%80%eb%8a%a5.png alt=image.png></p><ul><li><strong>@ManyToMany</strong> 사용</li><li><strong>@JoinTable</strong>로 연결 테이블 지정</li><li>다대다 매핑: 단방향, 양방향 가능</li></ul><h3 id=다대다-매핑의-한계>다대다 매핑의 한계<a hidden class=anchor aria-hidden=true href=#다대다-매핑의-한계>#</a></h3><ul><li><strong>편리해 보이지만 실무에서 사용X</strong></li><li>연결 테이블이 단순히 연결만 하고 끝나지 않음</li><li>주문시간, 수량 같은 데이터가 들어올 수 있음</li></ul><p><img loading=lazy src=images/%eb%8b%a4%eb%8c%80%eb%8b%a4%20%eb%a7%a4%ed%95%91%ec%9d%98%20%ed%95%9c%ea%b3%84.png alt=image.png></p><p>중간에 데이터를 추가하게 된다면 추가하지 못하게 된다.</p><h3 id=다대다-한계-극복>다대다 한계 극복<a hidden class=anchor aria-hidden=true href=#다대다-한계-극복>#</a></h3><ul><li><strong>연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)</strong></li><li><strong>@ManyToMany</strong> -> <strong>@OneToMany, @ManyToOne</strong></li></ul><p><img loading=lazy src=images/%eb%8b%a4%eb%8c%80%eb%8b%a4%20%ed%95%9c%ea%b3%84%ec%9d%98%20%ea%b7%b9%eb%b3%b5.png alt=image.png></p><p>Member와 Product를 연결해줄 MemberProduct 엔티티를 추가하면 된다. 그러면 MemberProcut 엔티티에 주문시간, 수량 같은 데이터 들이 중간에 들어올수 있다.</p><hr><h2 id=실전-예제---3다양한-연관관계-매핑>실전 예제 - 3.다양한 연관관계 매핑<a hidden class=anchor aria-hidden=true href=#실전-예제---3다양한-연관관계-매핑>#</a></h2><blockquote><p>실전 예제의 코드는 김영한님의 인프런 강의 <a href=https://www.inflearn.com/course/ORM-JPA-Basic>자바 ORM 표준 JPA 프로그래밍 - 기본편</a>에서 확인하실수 있습니다.</p></blockquote><ul><li>주문과 배송은 1:1(<strong>@OneToOne</strong>)</li><li>상품과 카테고리는 N:M(<strong>@ManyToMany</strong>)</li></ul><p><img loading=lazy src=images/%eb%8b%a4%ec%96%91%ed%95%9c%20%ec%97%b0%ea%b4%80%ea%b4%80%ea%b3%84%20%eb%a7%a4%ed%95%91.png alt=image.png></p><h3 id=배송-카테고리-추가---erd>배송, 카테고리 추가 - ERD<a hidden class=anchor aria-hidden=true href=#배송-카테고리-추가---erd>#</a></h3><p><img loading=lazy src=images/ERD.png alt=image.png></p><h3 id=배송-카테고리-추가---엔티티-상세>배송, 카테고리 추가 - 엔티티 상세<a hidden class=anchor aria-hidden=true href=#배송-카테고리-추가---엔티티-상세>#</a></h3><p><img loading=lazy src=images/%ec%97%94%ed%8b%b0%ed%8b%b0%20%ec%83%81%ec%84%b8.png alt=image.png></p><h3 id=nm-관계는-1n-n1로>N:M 관계는 1:N, N:1로<a hidden class=anchor aria-hidden=true href=#nm-관계는-1n-n1로>#</a></h3><ul><li>테이블의 N:M 관계는 중간 테이블을 이용해서 1:N, N:1</li><li>실전에서는 중간 테이블이 단순하지 않다.</li><li>@ManyToMany는 제약: 필드 추가X, 엔티티 테이블 불일치</li><li>실전에서는 <strong>@ManyToMany 사용X</strong></li></ul><h3 id=joincolumn>@JoinColumn<a hidden class=anchor aria-hidden=true href=#joincolumn>#</a></h3><table><thead><tr><th>속성</th><th>설명</th><th>기본값</th></tr></thead><tbody><tr><td>name</td><td>매핑할 외래 키 이름</td><td>필드명 + _ + 참조하는 테이블의 기본 키 컬럼명</td></tr><tr><td>referencedColumnName</td><td>외래 키가 참조하는 대상 테이블의 컬럼명</td><td>참조하는 테이블의 기본키 컬럼명</td></tr><tr><td>foreignKey(DDL)</td><td>외래 키 제약조건을 직접 지정할 수 있다.이 속성은 테이블을 생성할 때만 사용한다.</td><td></td></tr><tr><td>unique<br>nullable insertable<br>updatable<br>columnDefinition<br>table</td><td>@Column의 속성과 같다.</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id=manytoone---주요-속성>@ManyToOne - 주요 속성<a hidden class=anchor aria-hidden=true href=#manytoone---주요-속성>#</a></h3><p>다대일 관계 매핑</p><table><thead><tr><th>속성</th><th>설명</th><th>기본값</th></tr></thead><tbody><tr><td>optional</td><td>false로 설정하면 연관된 엔티티가 항상 있어야 한다.</td><td>TRUE</td></tr><tr><td>fetch</td><td>글로벌 페치 전략을 설정한다.</td><td>@ManyToOne=FetchType.EAGER<br>@OneToMany=FetchType.LAZY</td></tr><tr><td>cascade</td><td>영속성 전이 기능을 사용한다.</td><td></td></tr><tr><td>targetEntity</td><td>연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다.</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id=onetomany---주요-속성>@OneToMany - 주요 속성<a hidden class=anchor aria-hidden=true href=#onetomany---주요-속성>#</a></h3><p>일대다 관계 매핑</p><table><thead><tr><th>속성</th><th>설명</th><th>기본값</th></tr></thead><tbody><tr><td>mappedBy</td><td>연관관계의 주인 필드를 선택한다.</td><td></td></tr><tr><td>fetch</td><td>글로벌 페치 전략을 설정한다.</td><td>@ManyToOne=FetchType.EAGER @OneToMany=FetchType.LAZY</td></tr><tr><td>cascade</td><td>영속성 전이 기능을 사용한다.</td><td></td></tr><tr><td>targetEntity</td><td>연관된 엔티티의 타입 정보를 설정한다. 이 기능은 거의 사용하지 않는다. 컬렉션을 사용해도 제네릭으로 타입 정보를 알 수 있다</td><td></td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://yosong6729.github.io/tags/jpa/>JPA</a></li></ul><nav class=paginav><a class=prev href=https://yosong6729.github.io/post/%EA%B3%A0%EA%B8%89-%EB%A7%A4%ED%95%91/><span class=title>« Prev</span><br><span>[자바 ORM 표준 JPA 프로그래밍 - 기본편] 고급 매핑</span>
</a><a class=next href=https://yosong6729.github.io/post/%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91-%EA%B8%B0%EC%B4%88/><span class=title>Next »</span><br><span>[자바 ORM 표준 JPA 프로그래밍 - 기본편] 연관관계 매핑 기초</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yosong6729.github.io/>Yosong6729 Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>