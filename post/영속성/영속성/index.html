<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[자바 ORM 표준 JPA 프로그래밍 - 기본편] 영속성 관리 | Yosong6729 Blog</title>
<meta name=keywords content="JPA"><meta name=description content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
영속성 컨텍스트 JPA에서 가장 중요한 2가지 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping) 영속성 컨텍스트 영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻이다. 논리적인 개념이며 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있다.
생명주기 엔티티는 아래와 같은 생명주기가 존재한다.
비영속 (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속 (managed) 영속성 컨텍스트에 관리되는 상태 준영속 (detached) 영속성 컨텍스트에 저장되었다가 분리된 상 삭제 (removed) 삭제된 상태 비영속 1 2 3 4 //객체를 생성한 상태(비영속) Member member = new Member(); member."><meta name=author content="yosong6729"><link rel=canonical href=https://yosong6729.github.io/post/%EC%98%81%EC%86%8D%EC%84%B1/%EC%98%81%EC%86%8D%EC%84%B1/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yosong6729.github.io/post/%EC%98%81%EC%86%8D%EC%84%B1/%EC%98%81%EC%86%8D%EC%84%B1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="[자바 ORM 표준 JPA 프로그래밍 - 기본편] 영속성 관리"><meta property="og:description" content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
영속성 컨텍스트 JPA에서 가장 중요한 2가지 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping) 영속성 컨텍스트 영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻이다. 논리적인 개념이며 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있다.
생명주기 엔티티는 아래와 같은 생명주기가 존재한다.
비영속 (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속 (managed) 영속성 컨텍스트에 관리되는 상태 준영속 (detached) 영속성 컨텍스트에 저장되었다가 분리된 상 삭제 (removed) 삭제된 상태 비영속 1 2 3 4 //객체를 생성한 상태(비영속) Member member = new Member(); member."><meta property="og:type" content="article"><meta property="og:url" content="https://yosong6729.github.io/post/%EC%98%81%EC%86%8D%EC%84%B1/%EC%98%81%EC%86%8D%EC%84%B1/"><meta property="og:image" content="https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-09T18:21:27+09:00"><meta property="article:modified_time" content="2024-09-09T18:21:27+09:00"><meta property="og:site_name" content="Yosong6729 Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[자바 ORM 표준 JPA 프로그래밍 - 기본편] 영속성 관리"><meta name=twitter:description content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
영속성 컨텍스트 JPA에서 가장 중요한 2가지 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping) 영속성 컨텍스트 영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻이다. 논리적인 개념이며 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있다.
생명주기 엔티티는 아래와 같은 생명주기가 존재한다.
비영속 (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속 (managed) 영속성 컨텍스트에 관리되는 상태 준영속 (detached) 영속성 컨텍스트에 저장되었다가 분리된 상 삭제 (removed) 삭제된 상태 비영속 1 2 3 4 //객체를 생성한 상태(비영속) Member member = new Member(); member."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yosong6729.github.io/post/"},{"@type":"ListItem","position":2,"name":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 영속성 관리","item":"https://yosong6729.github.io/post/%EC%98%81%EC%86%8D%EC%84%B1/%EC%98%81%EC%86%8D%EC%84%B1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 영속성 관리","name":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 영속성 관리","description":"해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.\n영속성 컨텍스트 JPA에서 가장 중요한 2가지 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping) 영속성 컨텍스트 영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻이다. 논리적인 개념이며 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있다.\n생명주기 엔티티는 아래와 같은 생명주기가 존재한다.\n비영속 (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속 (managed) 영속성 컨텍스트에 관리되는 상태 준영속 (detached) 영속성 컨텍스트에 저장되었다가 분리된 상 삭제 (removed) 삭제된 상태 비영속 1 2 3 4 //객체를 생성한 상태(비영속) Member member = new Member(); member.","keywords":["JPA"],"articleBody":"해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.\n영속성 컨텍스트 JPA에서 가장 중요한 2가지 객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping) 영속성 컨텍스트 영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻이다. 논리적인 개념이며 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있다.\n생명주기 엔티티는 아래와 같은 생명주기가 존재한다.\n비영속 (new/transient) 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태 영속 (managed) 영속성 컨텍스트에 관리되는 상태 준영속 (detached) 영속성 컨텍스트에 저장되었다가 분리된 상 삭제 (removed) 삭제된 상태 비영속 1 2 3 4 //객체를 생성한 상태(비영속) Member member = new Member(); member.setId(\"member1\"); member.setUsername(\"회원1\"); 위와 같이 객체를 생성만 한 상태는 비영속 상태이다\n영속 1 2 3 4 5 6 7 8 //객체를 생성한 상태(비영속) Member member = new Member(); member.setId(\"member1\"); member.setUsername(“회원1”); EntityManager em = emf.createEntityManager(); em.getTransaction().begin(); //객체를 저장한 상태(영속) em.persist(member); 엔티티 매니저를 얻어와서 엔티티 매니저에 persist해서 멤버 객체를 집어 넣으면 엔티티 매니저 안에 있는 영속성 컨텍스트라는 곳에 멤버 객체가 들어가면서 영속 상태가 된다. em.persist(member)할때는 DB에 저장되지는 않는다. 즉 , 영속 상태가 된다고 해서 바로 DB에 쿼리가 날아가지는 않는다. 트랜잭션을 커밋하는 시점에 영속성 컨텍스트에 있는 것이 DB에 쿼리가 날아가게 된다.\n준영속, 삭제 1 2 3 4 5 //회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태 em.detach(member); //객체를 삭제한 상태(삭제) em.remove(member); em.remove는 실제 DB 삭제를 요청하는 상태라고 보면된다.\n영속성 컨텍스트의 이점 영속성 컨텍스트의 이점은 아래와 같다\n1차캐시 동일성 보장 트랜잭션을 지원하는 쓰기 지연 변경 감지 지연 로딩 엔티티 조회, 1차 캐시 //엔티티를 생성한 상태(비영속) Member member = new Member(); member.setId(\"member1\"); member.setUsername(\"회원1\"); //엔티티를 영속 em.persist(member); 위 사진에서 1차 캐시에 키인 @Id가 DB pk로 맵핑한 것이고 값이 엔티티 자체 값이 된다. 그래서 member id인 member1이 id가 되고 member 객체가 값이 된다.\n1차 캐시에서 조회 Member member = new Member(); member.setId(\"member1\"); member.setUsername(\"회원1\"); //1차 캐시에 저장됨 em.persist(member); //1차 캐시에서 조회 Member findMember = em.find(Member.class, \"member1\"); member객체를 저장 해놓고 조회를 하면 jpa는 em.find로 먼저 DB를 뒤지지 않고 1차 캐시를 확인하고 member 엔티티가 있으면 캐시에 있는 값을 조회해온다.\n데이터베이스에서 조회 Member findMember2 = em.find(Member.class, \"member2\"); 위 상황은 DB에는 member2가 있고 캐시에는 없는 경우입니다.\n먼저 find(”member2”)로 캐시를 확인하고 없으면 DB에서 조회한다. DB에서 조회한 member2를 1차 캐시에 저장하고 member2를 반환한다. 이후에 meber2를 다시 조회하면 영속성 컨텍스트 안에 있는 1차 캐시에 있는 멤버2가 반환이 된다. 이처럼 DB를 조회하지않고 값을 조회할수있는 이점이 있지만 큰도움은 되지 않는다. 이유는 엔티티 매니저는 데이터베이스 단위로 보통 만들고 데이터 베이스 트랜잭션이 끝날때 영속성 컨텍스트를 같이 종료시킨다. 즉, 고객의 요청이 하나 들어오면 보통 비즈니스가 끝나버리면 영속성 컨텍스트를 지워서 1차 캐시도 다 날아간다. 그리고 여러 명의 고객이 사용하는 캐쉬가 아니고 짧은 찰나의 순간에만 이득이 있기때문에 크게 성능의 이점을 얻을수 있는 장점은 없다. 하지만 복잡한 비즈니스 같은 경우에는 쿼리가 줄어드는 경우도 있다.\n영속 엔티티의 동일성 보장 Member a = em.find(Member.class, \"member1\"); Member b = em.find(Member.class, \"member1\"); System.out.println(a == b); //동일성 비교 true 1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다. 간단히 JPA에서 위 코드 처럼 같은 트랜잭션 안에서 실행을 하면 == 비교에서 True가 나온다고 이해하면 된다.\n엔티티 등록 트랜잭션을 지원하는 쓰기 지원 EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); //엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다. transaction.begin(); // [트랜잭션] 시작 em.persist(memberA); em.persist(memberB); //여기까지 INSERT SQL을 데이터베이스에 보내지 않는다. //커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다. transaction.commit(); // [트랜잭션] 커밋 em.persist에서 insert sql을 데이터 베이스에 보내지 않고 커밋 하는 순간에 데이터 베이스에 insert sql을 보낸다. em.persist(memberA)를 하면 memberA가 1차캐시에 들어감과 동시에 JPA가 memberA의 엔티티를 분석해서 insert 쿼리를 생성하여 쓰기 지연 SQL 저장소에 쌓아둔다. em.persist(memberB)도 동일하게 진행된다. 트랜잭션을 commit하는 시점에 쓰기 지연 SQL 저장소에 있던 애들이 flush가 되면서 DB로 날아간다. 그리고 실제 데이터 베이스 트랜잭션이 커밋된다.\n엔티티 수정 변경 감지 EntityManager em = emf.createEntityManager(); EntityTransaction transaction = em.getTransaction(); transaction.begin(); // [트랜잭션] 시작 // 영속 엔티티 조회 Member memberA = em.find(Member.class, \"memberA\"); // 영속 엔티티 데이터 수정 memberA.setUsername(\"hi\"); memberA.setAge(10); //em.update(member) 이런 코드가 있어야 하지 않을까? transaction.commit(); // [트랜잭션] 커밋 memberA의 값을 변경하고 변경한 값을 다시 저장하기 위해서 em.update(member) 같은 코드가 있어야 한다고 생각할수 있지만 그렇지 않다. em.update(member)가 필요없는 이유는 다음과 같다. JPA는 데이터베이스 트랜잭션을 커밋하는 시점에 내부적으로 flush가 호출된다. 그리고 엔티티와 스냅샷(값을 읽어온 최초 시점의 상태)을 비교한다. 비교해서 값이 바뀌었으면 update 쿼리를 쓰기 지연 SQL 저장소에 만든다. 그리고 업데이트 쿼리를 데이터베이스에 반영하고 커밋한다. 이것을 변경감지라고 한다.\n엔티티 삭제 //삭제 대상 엔티티 조회 Member memberA = em.find(Member.class, \"memberA\"); em.remove(memberA); //엔티티 삭제 트랜잭션 커밋 시점에 delete 쿼리가 나가게 된다.\n플러시 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것이다.\n플러시 발생 플러시를 발생시키는 경우는 아래와 같다.\n변경 감지 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리) 영속성 컨텍스트를 플러시 하는 방법 양석상 컨텍스트를 플러시 하는 방법은 다음과 같다.\nem.flush() - 직접 호출 트랜잭션 커밋 - 플러시 자동 호출 JPQL 쿼리 실행 - 플러시 자동 호출 JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유 em.persist(memberA); em.persist(memberB); em.persist(memberC); //중간에 JPQL 실행 query = em.createQuery(\"select m from Member m\", Member.class); List\u003cMember\u003e members= query.getResultList(); em.persist()로 member A, B, C를 저장했는데 이때는 실제 데이터베이스에 쿼리가 날아가지는 않는다. 그래서 중간에 JPQL을 실행하게 되면 member를 DB에서 가져올게 없게 된다. 이런 문제를 방지하고자 JPQL은 실행할떄 무조건 flush를 날려버린다.\n플러시는 영속성 컨텍스를 비우는게 아니라 영속성 컨텍스트의 변경 내용을 데이터베이스 동기화 하는거라고 이해하면 된다. 이러한 매커니즘이 가능한 이유는 트랜잭션이라는 작업 단위의 존재 때문이다. 즉, 커밋 직전에만 동기화하면 되기 때문에 가능한 것이다.\n준영속 상태 준영속 상태는 영속 상태의 엔티티가 연속성 컨텍스트에서 분리되는 것을 말한다. 준영속 상태가 되면 영속성 컨텍스트가 제공하는 기능(dirty checking 등)을 사용하지 못한다.\n준영속 상태로 만드는 방법 준영속 상태로 만드는 방법은 다음과 같다.\nem.detach(entity) - 특정 엔티티만 준영속 상태로 전환 em.clear() - 영속성 컨텍스트를 완전히 초기화 em.close() - 영속성 컨텍스트를 종료 ","wordCount":"901","inLanguage":"en","image":"https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-09T18:21:27+09:00","dateModified":"2024-09-09T18:21:27+09:00","author":{"@type":"Person","name":"yosong6729"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yosong6729.github.io/post/%EC%98%81%EC%86%8D%EC%84%B1/%EC%98%81%EC%86%8D%EC%84%B1/"},"publisher":{"@type":"Organization","name":"Yosong6729 Blog","logo":{"@type":"ImageObject","url":"https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yosong6729.github.io/ accesskey=h title="Yosong6729 블로그 (Alt + H)"><img src=https://yosong6729.github.io/apple-touch-icon.png alt aria-label=logo height=35>Yosong6729 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yosong6729.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://yosong6729.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yosong6729.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yosong6729.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">[자바 ORM 표준 JPA 프로그래밍 - 기본편] 영속성 관리</h1><div class=post-meta><span title='2024-09-09 18:21:27 +0900 KST'>September 9, 2024</span>&nbsp;·&nbsp;yosong6729&nbsp;|&nbsp;<a href=https://github.com/yosong6729/blog/tree/main/content/post/%ec%98%81%ec%86%8d%ec%84%b1/%ec%98%81%ec%86%8d%ec%84%b1.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%98%81%ec%86%8d%ec%84%b1-%ec%bb%a8%ed%85%8d%ec%8a%a4%ed%8a%b8 aria-label="영속성 컨텍스트">영속성 컨텍스트</a></li><li><a href=#jpa%ec%97%90%ec%84%9c-%ea%b0%80%ec%9e%a5-%ec%a4%91%ec%9a%94%ed%95%9c-2%ea%b0%80%ec%a7%80 aria-label="JPA에서 가장 중요한 2가지">JPA에서 가장 중요한 2가지</a></li><li><a href=#%ec%83%9d%eb%aa%85%ec%a3%bc%ea%b8%b0 aria-label=생명주기>생명주기</a></li><li><a href=#%eb%b9%84%ec%98%81%ec%86%8d aria-label=비영속>비영속</a></li><li><a href=#%ec%98%81%ec%86%8d aria-label=영속>영속</a></li><li><a href=#%ec%a4%80%ec%98%81%ec%86%8d-%ec%82%ad%ec%a0%9c aria-label="준영속, 삭제">준영속, 삭제</a></li><li><a href=#%ec%98%81%ec%86%8d%ec%84%b1-%ec%bb%a8%ed%85%8d%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%9d%b4%ec%a0%90 aria-label="영속성 컨텍스트의 이점">영속성 컨텍스트의 이점</a></li><li><a href=#%ec%97%94%ed%8b%b0%ed%8b%b0-%ec%a1%b0%ed%9a%8c-1%ec%b0%a8-%ec%ba%90%ec%8b%9c aria-label="엔티티 조회, 1차 캐시">엔티티 조회, 1차 캐시</a></li><li><a href=#1%ec%b0%a8-%ec%ba%90%ec%8b%9c%ec%97%90%ec%84%9c-%ec%a1%b0%ed%9a%8c aria-label="1차 캐시에서 조회">1차 캐시에서 조회</a></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4%ec%97%90%ec%84%9c-%ec%a1%b0%ed%9a%8c aria-label="데이터베이스에서 조회">데이터베이스에서 조회</a></li><li><a href=#%ec%98%81%ec%86%8d-%ec%97%94%ed%8b%b0%ed%8b%b0%ec%9d%98-%eb%8f%99%ec%9d%bc%ec%84%b1-%eb%b3%b4%ec%9e%a5 aria-label="영속 엔티티의 동일성 보장">영속 엔티티의 동일성 보장</a></li><li><a href=#%ec%97%94%ed%8b%b0%ed%8b%b0-%eb%93%b1%eb%a1%9d aria-label="엔티티 등록">엔티티 등록</a></li><li><a href=#%ed%8a%b8%eb%9e%9c%ec%9e%ad%ec%85%98%ec%9d%84-%ec%a7%80%ec%9b%90%ed%95%98%eb%8a%94-%ec%93%b0%ea%b8%b0-%ec%a7%80%ec%9b%90 aria-label="트랜잭션을 지원하는 쓰기 지원">트랜잭션을 지원하는 쓰기 지원</a></li><li><a href=#%ec%97%94%ed%8b%b0%ed%8b%b0-%ec%88%98%ec%a0%95 aria-label="엔티티 수정">엔티티 수정</a></li><li><a href=#%eb%b3%80%ea%b2%bd-%ea%b0%90%ec%a7%80 aria-label="변경 감지">변경 감지</a></li><li><a href=#%ec%97%94%ed%8b%b0%ed%8b%b0-%ec%82%ad%ec%a0%9c aria-label="엔티티 삭제">엔티티 삭제</a></li><li><a href=#%ed%94%8c%eb%9f%ac%ec%8b%9c aria-label=플러시>플러시</a></li><li><a href=#%ed%94%8c%eb%9f%ac%ec%8b%9c-%eb%b0%9c%ec%83%9d aria-label="플러시 발생">플러시 발생</a></li><li><a href=#%ec%98%81%ec%86%8d%ec%84%b1-%ec%bb%a8%ed%85%8d%ec%8a%a4%ed%8a%b8%eb%a5%bc-%ed%94%8c%eb%9f%ac%ec%8b%9c-%ed%95%98%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="영속성 컨텍스트를 플러시 하는 방법">영속성 컨텍스트를 플러시 하는 방법</a></li><li><a href=#jpql-%ec%bf%bc%eb%a6%ac-%ec%8b%a4%ed%96%89%ec%8b%9c-%ed%94%8c%eb%9f%ac%ec%8b%9c%ea%b0%80-%ec%9e%90%eb%8f%99%ec%9c%bc%eb%a1%9c-%ed%98%b8%ec%b6%9c%eb%90%98%eb%8a%94-%ec%9d%b4%ec%9c%a0 aria-label="JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유">JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유</a></li><li><a href=#%ec%a4%80%ec%98%81%ec%86%8d-%ec%83%81%ed%83%9c aria-label="준영속 상태">준영속 상태</a></li><li><a href=#%ec%a4%80%ec%98%81%ec%86%8d-%ec%83%81%ed%83%9c%eb%a1%9c-%eb%a7%8c%eb%93%9c%eb%8a%94-%eb%b0%a9%eb%b2%95 aria-label="준영속 상태로 만드는 방법">준영속 상태로 만드는 방법</a></li></ul></div></details></div><div class=post-content><p>해당 글은 김영한님의 인프런 강의 <a href=https://www.inflearn.com/course/ORM-JPA-Basic>자바 ORM 표준 JPA 프로그래밍 - 기본편</a>을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.</p><h3 id=영속성-컨텍스트>영속성 컨텍스트<a hidden class=anchor aria-hidden=true href=#영속성-컨텍스트>#</a></h3><hr><h3 id=jpa에서-가장-중요한-2가지>JPA에서 가장 중요한 2가지<a hidden class=anchor aria-hidden=true href=#jpa에서-가장-중요한-2가지>#</a></h3><ul><li>객체와 관계형 데이터베이스 매핑하기(Object Relational Mapping)</li><li>영속성 컨텍스트</li></ul><p>영속성 컨텍스트는 <strong>엔티티를 영구 저장하는 환경</strong>이라는 뜻이다. 논리적인 개념이며 눈에 보이지 않는다. 엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있다.</p><hr><h3 id=생명주기>생명주기<a hidden class=anchor aria-hidden=true href=#생명주기>#</a></h3><p>엔티티는 아래와 같은 생명주기가 존재한다.</p><ul><li>비영속 (new/transient)
영속성 컨텍스트와 전혀 관계가 없는 새로운 상태</li><li>영속 (managed)
영속성 컨텍스트에 관리되는 상태</li><li>준영속 (detached)
영속성 컨텍스트에 저장되었다가 분리된 상</li><li>삭제 (removed)
삭제된 상태</li></ul><hr><h3 id=비영속>비영속<a hidden class=anchor aria-hidden=true href=#비영속>#</a></h3><p><img loading=lazy src=../images/%eb%b9%84%ec%98%81%ec%86%8d.png alt=비영속></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//객체를 생성한 상태(비영속)  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>member</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Member</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>setUsername</span><span class=p>(</span><span class=s>&#34;회원1&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>위와 같이 객체를 생성만 한 상태는 비영속 상태이다</p><hr><h3 id=영속>영속<a hidden class=anchor aria-hidden=true href=#영속>#</a></h3><p><img loading=lazy src=../images/%ec%98%81%ec%86%8d.png alt=영속></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//객체를 생성한 상태(비영속)  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>member</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Member</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>setUsername</span><span class=p>(</span><span class=err>“</span><span class=n>회원1</span><span class=err>”</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>EntityManager</span><span class=w> </span><span class=n>em</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>emf</span><span class=p>.</span><span class=na>createEntityManager</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>getTransaction</span><span class=p>().</span><span class=na>begin</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//객체를 저장한 상태(영속)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>member</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>엔티티 매니저를 얻어와서 엔티티 매니저에 persist해서 멤버 객체를 집어 넣으면 엔티티 매니저 안에 있는 영속성 컨텍스트라는 곳에 멤버 객체가 들어가면서 영속 상태가 된다.
em.persist(member)할때는 DB에 저장되지는 않는다. 즉 , 영속 상태가 된다고 해서 바로 DB에 쿼리가 날아가지는 않는다. 트랜잭션을 커밋하는 시점에 영속성 컨텍스트에 있는 것이 DB에 쿼리가 날아가게 된다.</p><hr><h3 id=준영속-삭제>준영속, 삭제<a hidden class=anchor aria-hidden=true href=#준영속-삭제>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>detach</span><span class=p>(</span><span class=n>member</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//객체를 삭제한 상태(삭제)  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>member</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>em.remove는 실제 DB 삭제를 요청하는 상태라고 보면된다.</p><hr><h3 id=영속성-컨텍스트의-이점>영속성 컨텍스트의 이점<a hidden class=anchor aria-hidden=true href=#영속성-컨텍스트의-이점>#</a></h3><p>영속성 컨텍스트의 이점은 아래와 같다</p><ul><li>1차캐시</li><li>동일성 보장</li><li>트랜잭션을 지원하는 쓰기 지연</li><li>변경 감지</li><li>지연 로딩</li></ul><h3 id=엔티티-조회-1차-캐시>엔티티 조회, 1차 캐시<a hidden class=anchor aria-hidden=true href=#엔티티-조회-1차-캐시>#</a></h3><p><img loading=lazy src=../images/1%ec%b0%a8%ec%ba%90%ec%8b%9c.png alt="1차 캐시"></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//엔티티를 생성한 상태(비영속)  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>member</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Member</span><span class=p>();</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>setUsername</span><span class=p>(</span><span class=s>&#34;회원1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//엔티티를 영속  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>member</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p>위 사진에서 1차 캐시에 키인 @Id가 DB pk로 맵핑한 것이고 값이 엔티티 자체 값이 된다. 그래서 member id인 member1이 id가 되고 member 객체가 값이 된다.</p><hr><h3 id=1차-캐시에서-조회>1차 캐시에서 조회<a hidden class=anchor aria-hidden=true href=#1차-캐시에서-조회>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Member</span><span class=w> </span><span class=n>member</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>Member</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>setId</span><span class=p>(</span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>member</span><span class=p>.</span><span class=na>setUsername</span><span class=p>(</span><span class=s>&#34;회원1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//1차 캐시에 저장됨</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>member</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//1차 캐시에서 조회</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>findMember</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=../images/1%ec%b0%a8%ec%ba%90%ec%8b%9c%ec%97%90%ec%84%9c%ec%a1%b0%ed%9a%8c.png alt="1차 캐시에서 조회">
member객체를 저장 해놓고 조회를 하면 jpa는 em.find로 먼저 DB를 뒤지지 않고 1차 캐시를 확인하고 member 엔티티가 있으면 캐시에 있는 값을 조회해온다.</p><hr><h3 id=데이터베이스에서-조회>데이터베이스에서 조회<a hidden class=anchor aria-hidden=true href=#데이터베이스에서-조회>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Member</span><span class=w> </span><span class=n>findMember2</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=s>&#34;member2&#34;</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=../images/%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4%ec%97%90%ec%84%9c%ec%a1%b0%ed%9a%8c.png alt="데이터베이스에서 조회">
위 상황은 DB에는 member2가 있고 캐시에는 없는 경우입니다.</p><p>먼저 find(”member2”)로 캐시를 확인하고 없으면 DB에서 조회한다. DB에서 조회한 member2를 1차 캐시에 저장하고 member2를 반환한다.
이후에 meber2를 다시 조회하면 영속성 컨텍스트 안에 있는 1차 캐시에 있는 멤버2가 반환이 된다.
이처럼 DB를 조회하지않고 값을 조회할수있는 이점이 있지만 큰도움은 되지 않는다.
이유는 엔티티 매니저는 데이터베이스 단위로 보통 만들고 데이터 베이스 트랜잭션이 끝날때 영속성 컨텍스트를 같이 종료시킨다. 즉, 고객의 요청이 하나 들어오면 보통 비즈니스가 끝나버리면 영속성 컨텍스트를 지워서 1차 캐시도 다 날아간다. 그리고 여러 명의 고객이 사용하는 캐쉬가 아니고 짧은 찰나의 순간에만 이득이 있기때문에 크게 성능의 이점을 얻을수 있는 장점은 없다. 하지만 복잡한 비즈니스 같은 경우에는 쿼리가 줄어드는 경우도 있다.</p><h3 id=영속-엔티티의-동일성-보장>영속 엔티티의 동일성 보장<a hidden class=anchor aria-hidden=true href=#영속-엔티티의-동일성-보장>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>Member</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=s>&#34;member1&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>System</span><span class=p>.</span><span class=na>out</span><span class=p>.</span><span class=na>println</span><span class=p>(</span><span class=n>a</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>b</span><span class=p>);</span><span class=w> </span><span class=c1>//동일성 비교 true</span><span class=w>
</span></span></span></code></pre></div><p>1차 캐시로 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다. 간단히 JPA에서 위 코드 처럼 같은 트랜잭션 안에서 실행을 하면 == 비교에서 True가 나온다고 이해하면 된다.</p><hr><h3 id=엔티티-등록>엔티티 등록<a hidden class=anchor aria-hidden=true href=#엔티티-등록>#</a></h3><h3 id=트랜잭션을-지원하는-쓰기-지원>트랜잭션을 지원하는 쓰기 지원<a hidden class=anchor aria-hidden=true href=#트랜잭션을-지원하는-쓰기-지원>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>EntityManager</span><span class=w> </span><span class=n>em</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>emf</span><span class=p>.</span><span class=na>createEntityManager</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>EntityTransaction</span><span class=w> </span><span class=n>transaction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>getTransaction</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>transaction</span><span class=p>.</span><span class=na>begin</span><span class=p>();</span><span class=w>  </span><span class=c1>// [트랜잭션] 시작</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>memberA</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>memberB</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>transaction</span><span class=p>.</span><span class=na>commit</span><span class=p>();</span><span class=w> </span><span class=c1>// [트랜잭션] 커밋</span><span class=w>
</span></span></span></code></pre></div><p>em.persist에서 insert sql을 데이터 베이스에 보내지 않고 커밋 하는 순간에 데이터 베이스에 insert sql을 보낸다.
<img loading=lazy src=../images/%ec%97%94%ed%8b%b0%ed%8b%b0%20%eb%93%b1%eb%a1%9d1.png alt="엔티티 등록1">
em.persist(memberA)를 하면 memberA가 1차캐시에 들어감과 동시에 JPA가 memberA의 엔티티를 분석해서 insert 쿼리를 생성하여 쓰기 지연 SQL 저장소에 쌓아둔다. em.persist(memberB)도 동일하게 진행된다.
<img loading=lazy src=../images/%ec%97%94%ed%8b%b0%ed%8b%b0%20%eb%93%b1%eb%a1%9d2.png alt="엔티티 등록2">
트랜잭션을 commit하는 시점에 쓰기 지연 SQL 저장소에 있던 애들이 flush가 되면서 DB로 날아간다. 그리고 실제 데이터 베이스 트랜잭션이 커밋된다.</p><hr><h3 id=엔티티-수정>엔티티 수정<a hidden class=anchor aria-hidden=true href=#엔티티-수정>#</a></h3><h3 id=변경-감지>변경 감지<a hidden class=anchor aria-hidden=true href=#변경-감지>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>EntityManager</span><span class=w> </span><span class=n>em</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>emf</span><span class=p>.</span><span class=na>createEntityManager</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>EntityTransaction</span><span class=w> </span><span class=n>transaction</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>getTransaction</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>transaction</span><span class=p>.</span><span class=na>begin</span><span class=p>();</span><span class=w>  </span><span class=c1>// [트랜잭션] 시작</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 영속 엔티티 조회</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>memberA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=s>&#34;memberA&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// 영속 엔티티 데이터 수정</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>memberA</span><span class=p>.</span><span class=na>setUsername</span><span class=p>(</span><span class=s>&#34;hi&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>memberA</span><span class=p>.</span><span class=na>setAge</span><span class=p>(</span><span class=n>10</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//em.update(member) 이런 코드가 있어야 하지 않을까?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>transaction</span><span class=p>.</span><span class=na>commit</span><span class=p>();</span><span class=w> </span><span class=c1>// [트랜잭션] 커밋</span><span class=w>
</span></span></span></code></pre></div><p>memberA의 값을 변경하고 변경한 값을 다시 저장하기 위해서 em.update(member) 같은 코드가 있어야 한다고 생각할수 있지만 그렇지 않다.
em.update(member)가 필요없는 이유는 다음과 같다.
<img loading=lazy src=../images/%eb%b3%80%ea%b2%bd%ea%b0%90%ec%a7%80.png alt=변경감지>
JPA는 데이터베이스 트랜잭션을 커밋하는 시점에 내부적으로 flush가 호출된다. 그리고 엔티티와 스냅샷(값을 읽어온 최초 시점의 상태)을 비교한다. 비교해서 값이 바뀌었으면 update 쿼리를 쓰기 지연 SQL 저장소에 만든다. 그리고 업데이트 쿼리를 데이터베이스에 반영하고 커밋한다. 이것을 변경감지라고 한다.</p><hr><h3 id=엔티티-삭제>엔티티 삭제<a hidden class=anchor aria-hidden=true href=#엔티티-삭제>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//삭제 대상 엔티티 조회  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Member</span><span class=w> </span><span class=n>memberA</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>find</span><span class=p>(</span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>,</span><span class=w> </span><span class=s>&#34;memberA&#34;</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>remove</span><span class=p>(</span><span class=n>memberA</span><span class=p>);</span><span class=w> </span><span class=c1>//엔티티 삭제</span><span class=w>
</span></span></span></code></pre></div><p>트랜잭션 커밋 시점에 delete 쿼리가 나가게 된다.</p><hr><h3 id=플러시>플러시<a hidden class=anchor aria-hidden=true href=#플러시>#</a></h3><p>영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것이다.</p><h3 id=플러시-발생>플러시 발생<a hidden class=anchor aria-hidden=true href=#플러시-발생>#</a></h3><p>플러시를 발생시키는 경우는 아래와 같다.</p><ul><li>변경 감지</li><li>수정된 엔티티 쓰기 지연 SQL 저장소에 등록</li><li>쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)</li></ul><h3 id=영속성-컨텍스트를-플러시-하는-방법>영속성 컨텍스트를 플러시 하는 방법<a hidden class=anchor aria-hidden=true href=#영속성-컨텍스트를-플러시-하는-방법>#</a></h3><p>양석상 컨텍스트를 플러시 하는 방법은 다음과 같다.</p><ul><li>em.flush() - 직접 호출</li><li>트랜잭션 커밋 - 플러시 자동 호출</li><li>JPQL 쿼리 실행 - 플러시 자동 호출</li></ul><h3 id=jpql-쿼리-실행시-플러시가-자동으로-호출되는-이유>JPQL 쿼리 실행시 플러시가 자동으로 호출되는 이유<a hidden class=anchor aria-hidden=true href=#jpql-쿼리-실행시-플러시가-자동으로-호출되는-이유>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>memberA</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>memberB</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>em</span><span class=p>.</span><span class=na>persist</span><span class=p>(</span><span class=n>memberC</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>//중간에 JPQL 실행</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>query</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>em</span><span class=p>.</span><span class=na>createQuery</span><span class=p>(</span><span class=s>&#34;select m from Member m&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Member</span><span class=p>.</span><span class=na>class</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>List</span><span class=o>&lt;</span><span class=n>Member</span><span class=o>&gt;</span><span class=w> </span><span class=n>members</span><span class=o>=</span><span class=w> </span><span class=n>query</span><span class=p>.</span><span class=na>getResultList</span><span class=p>();</span><span class=w>
</span></span></span></code></pre></div><p>em.persist()로 member A, B, C를 저장했는데 이때는 실제 데이터베이스에 쿼리가 날아가지는 않는다. 그래서 중간에 JPQL을 실행하게 되면 member를 DB에서 가져올게 없게 된다. 이런 문제를 방지하고자 JPQL은 실행할떄 무조건 flush를 날려버린다.</p><p><strong>플러시는</strong> 영속성 컨텍스를 비우는게 아니라 영속성 컨텍스트의 변경 내용을 데이터베이스 동기화 하는거라고 이해하면 된다. 이러한 매커니즘이 가능한 이유는 트랜잭션이라는 작업 단위의 존재 때문이다. 즉, 커밋 직전에만 동기화하면 되기 때문에 가능한 것이다.</p><hr><h3 id=준영속-상태>준영속 상태<a hidden class=anchor aria-hidden=true href=#준영속-상태>#</a></h3><p>준영속 상태는 영속 상태의 엔티티가 연속성 컨텍스트에서 분리되는 것을 말한다. 준영속 상태가 되면 영속성 컨텍스트가 제공하는 기능(dirty checking 등)을 사용하지 못한다.</p><h3 id=준영속-상태로-만드는-방법>준영속 상태로 만드는 방법<a hidden class=anchor aria-hidden=true href=#준영속-상태로-만드는-방법>#</a></h3><p>준영속 상태로 만드는 방법은 다음과 같다.</p><ul><li>em.detach(entity) - 특정 엔티티만 준영속 상태로 전환</li><li>em.clear() - 영속성 컨텍스트를 완전히 초기화</li><li>em.close() - 영속성 컨텍스트를 종료</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yosong6729.github.io/tags/jpa/>JPA</a></li></ul><nav class=paginav><a class=next href=https://yosong6729.github.io/post/new-post/><span class=title>Next »</span><br><span>New Post</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yosong6729.github.io/>Yosong6729 Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>