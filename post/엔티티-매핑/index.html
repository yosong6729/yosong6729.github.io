<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[자바 ORM 표준 JPA 프로그래밍 - 기본편] 엔티티 매핑 | Yosong6729 Blog</title>
<meta name=keywords content="JPA"><meta name=description content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
엔티티 매핑 객체와 테이블 매핑: @Entity, @Table 필드와 컬럼 매핑: @Column 기본 키 매핑: @Id 연관관계 매핑: @ManyToOne,@JoinColumn 객체와 테이블 매핑 @Entity
@Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스 사용X 저장할 필드에 final 사용 X @Entity 속성 정리"><meta name=author content="yosong6729"><link rel=canonical href=https://yosong6729.github.io/post/%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yosong6729.github.io/post/%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="[자바 ORM 표준 JPA 프로그래밍 - 기본편] 엔티티 매핑"><meta property="og:description" content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
엔티티 매핑 객체와 테이블 매핑: @Entity, @Table 필드와 컬럼 매핑: @Column 기본 키 매핑: @Id 연관관계 매핑: @ManyToOne,@JoinColumn 객체와 테이블 매핑 @Entity
@Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스 사용X 저장할 필드에 final 사용 X @Entity 속성 정리"><meta property="og:type" content="article"><meta property="og:url" content="https://yosong6729.github.io/post/%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91/"><meta property="og:image" content="https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-09-10T21:26:15+09:00"><meta property="article:modified_time" content="2024-09-10T21:26:15+09:00"><meta property="og:site_name" content="Yosong6729 Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[자바 ORM 표준 JPA 프로그래밍 - 기본편] 엔티티 매핑"><meta name=twitter:description content="해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.
엔티티 매핑 객체와 테이블 매핑: @Entity, @Table 필드와 컬럼 매핑: @Column 기본 키 매핑: @Id 연관관계 매핑: @ManyToOne,@JoinColumn 객체와 테이블 매핑 @Entity
@Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스 사용X 저장할 필드에 final 사용 X @Entity 속성 정리"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yosong6729.github.io/post/"},{"@type":"ListItem","position":2,"name":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 엔티티 매핑","item":"https://yosong6729.github.io/post/%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 엔티티 매핑","name":"[자바 ORM 표준 JPA 프로그래밍 - 기본편] 엔티티 매핑","description":"해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.\n엔티티 매핑 객체와 테이블 매핑: @Entity, @Table 필드와 컬럼 매핑: @Column 기본 키 매핑: @Id 연관관계 매핑: @ManyToOne,@JoinColumn 객체와 테이블 매핑 @Entity\n@Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스 사용X 저장할 필드에 final 사용 X @Entity 속성 정리","keywords":["JPA"],"articleBody":"해당 글은 김영한님의 인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.\n엔티티 매핑 객체와 테이블 매핑: @Entity, @Table 필드와 컬럼 매핑: @Column 기본 키 매핑: @Id 연관관계 매핑: @ManyToOne,@JoinColumn 객체와 테이블 매핑 @Entity\n@Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자) final 클래스, enum, interface, inner 클래스 사용X 저장할 필드에 final 사용 X @Entity 속성 정리\n속성: name JPA에서 사용할 엔티티 이름을 지정한다. 기본값: 클래스 이름을 그대로 사용(예: Member) 같은 클래스 이름이 없으면 가급적 기본값을 사용한다. @Table\n@Table은 엔티티와 매핑할 테이블 지정 속성 기능 기본값 name 매핑할 테이블 이름 엔티티 이름을 사용 catalog 데이터베이스 catalog 매핑 schema 데이터베이스 schema 매핑 uniqueConstraints(DDL) DDL 생성 시에 유니크 제약 조건 생성 데이터베이스 스키마 자동 생성 JPA 사용시 DDL을 애플리케이션 실행 시점에 자동 생성한다.\n테이블 중심 -\u003e 객체 중심 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성 이렇게 생성된 DDL은 개발 장비에서만 사용(운영에서 사용X) 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용 데이터베이스 스키마 자동 생성 - 속성 hibernate.hbm2ddl.auto\n옵션 설명 create 기존테이블 삭제 후 다시 생성(DROP + CREATE) create-drop create와 같으나 종료시점에 테이블 DROP update 변경분만 반영(운영DB에는 사용하면 안됨) validate 엔티티와 테이블이 정상 매핑되었는지만 확인 none 사용하지 않음 데이터베이스 스키마 자동 생성 - 주의 운영 장비에는 절대 create, create-drop, update 사용하면 안된다. 개발 초기 단계는 create 또는 updat 테스트 서버는 update 또는 validate 스테이징과 운영 서버는 validate 또는 none DDL 생성 기능 제약조건 추가: 회원 이름은 필수, 10자 초과X @Column(nullable = false, length = 10) 유니크 제약조건 추가 Column(unique = true) DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.\n필드와 컬럼 매핑 요구사항 추가\n회원은 일반 회원과 관리자로 구분해야 한다. 회원 가입일과 수정일이 있어야 한다. 회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다. @Entity public class Member { @Id private Long id; @Column(name = \"name\") private String username; private Integer age; @Enumerated(EnumType.STRING) private RoleType roleType; @Temporal(TemporalType.TIMESTAMP) private Date createdDate; @Temporal(TemporalType.TIMESTAMP) private Date lastModifiedDate; @Lob private String description; //Getter, Setter… } @Id는 PK를 매핑 한것이다. 객체에는 “username”이라고 쓰고 DB 컬럼명으로는 “name”이라고 쓰고 싶으면 @Column(name = “name”)을 사용한다. Integer타입을 쓰면 타입과 가장 적절한 숫자 타입이 만들어진다. @Enumerated를 사용하면 enum 타입을 사용할수 있다. @Temporal을 사용하면 날짜 정보를 저장할수 있다. TemporalType으로는 Date(날짜), Time(시간), TIMESTAMP(날짜, 시간)이 있다. varchar을 넘어서는 큰 값을 넣고 싶으면 @Lob을 사용하면 된다. 매핑 어노테이션 정리 hibernate.hbm2ddl.auto\n어노테이션 설명 @Column 컬럼 매핑 @Temporal 날짜 타입 매핑 @Enumerated enum 타입 매핑 @Lob BLOB, CLOB 매핑 @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시) @Column 속성 설명 기본값 name 필드와 매핑할 테이블의 컬럼 이름 객체의 필드 이름 insertable, updatable 등록, 변경 가능 여부 TRUE nullable(DDL) null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다 unique(DDL) @Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다. columnDefinition(DDL) 데이터베이스 컬럼 정보를 직접 줄 수 있다.ex) varchar(100) default ‘EMPTY' 필드의 자바 타입과 방언 정보를 사용 length(DDL) 문자 길이 제약조건, String 타입에만 사용한다. 255 precision, scale(DDL) BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다). precision은 소수점을 포함한 전체 자 릿수를, scale은 소수의 자릿수다. 참고로 double, float 타입에는 적용되지 않는다. 아주 큰 숫자나 정 밀한 소수를 다루어야 할 때만 사용한다. precision=19, scale=2 Unique(DDL)은 sql 로그에 유니크 제약조건 이름이 랜덤명처럼 나와서 식별하기 힘들다. 그래서 제약조건 이름 설정이 가능한uniqueConstraints를 사용하는게 좋다.\n@Enumerated 자바 enum 타입을 매핑할 때 사용한다.\n주의! ORDINAL 사용X\n속성 설명 기본값 value • EnumType.ORDINAL: enum 순서를 데이터베이스에 저장 • EnumType.STRING: enum 이름을 데이터베이스에 저장 EnumType.ORDINAL public enum RoleType{ USER, ADMIN } ORDINAL을 사용하면 안되는 이유는 만약 위처럼 enum의 값이 있다고 한다면 DB에는 USER는 0, ADMIN은 1이 저장된다. 하지만 이후에 GUEST가 추가되었다고 가정해보자.\npublic enum RoleType{ //GUEST 추가 GUEST, USER, ADMIN } 이렇게 GUEST가 추가가 된다면 DB에 GUEST가 0으로 저장되는데 이전에 저장된 USER의 값도 0이기때문에 큰일이 일어난다.\nTemporal 날짜 타입(java.util.Date, java.util.Calendar)을 매핑할 때 사용한다\nLocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원)\n속성 설명 value •TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑(예: 2013–10–11) •TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑(예: 11:11:11) •TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(예: 2013–10–11 11:11:11) @Lob 데이터베이스 BLOB, CLOB 타입과 매핑\n@Lob에는 지정할 수 있는 속성이 없다. 매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑 CLOB: String, char[], java.sql.CLOB BLOB: byte[], java.sql. BLOB @Transient 필드 매핑X 데이터베이스에 저장X, 조회X 주로 메모리상에서만 임시로 어떤 값을 보관하고 싶을 때 사용 @Transient\nprivate Integer temp; 기본 키 매핑 기본 키 매핑 어노테이션 @Id @GeneratedValue @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; 기본 키 매핑 방법 직접 할당: @Id만 사용 자동 생성(@GeneratedValue) IDENTITY: 데이터베이스에 위임, MYSQL SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE @SequenceGenerator 필요 TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용 @TableGenerator 필요 AUTO: 방언에 따라 자동 지정, 기본값 IDENTITY 전략 - 특징 기본 키 생성을 데이터베이스에 위임 주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용(예: MySQL의 AUTO_ INCREMENT) JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행 AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있음 IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자를 조회 IDENTITY 전략 - 매핑 @Entity public class Member { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; SEQUENCE 전략 - 특징 데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트(예: 오라클 시퀀스) 오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용 SEQUENCE 전략 - 매핑 @Entity @SequenceGenerator( name = “MEMBER_SEQ_GENERATOR\", sequenceName = “MEMBER_SEQ\", //매핑할 데이터베이스 시퀀스 이름 initialValue = 1, allocationSize = 1) public class Member { @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"MEMBER_SEQ_GENERATOR\") private Long id; identity와 다르게 em.persist()하는 시점에 데이터베이스 시퀀스를 이용하여 식별자를 조회(call next value for …)한다. 그리고 조회한 식별자를 엔티티에 할당한 후 엔티티 를 영속성 컨텍스트에 저장한다(Identity에서 되지 않는 버퍼링이 가능하다.). 이후 커밋시점에 데이터베이스에 저장한다.\nSEQUENCE - @SequenceGenerator •주의: allocationSize 기본값 = 50\n속성 설명 기본값 name 식별자 생성기 이름 필수 sequenceName 데잍베이스에 등록되어 있는 시퀀스 이름 hibernate_sequence initialValue DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 때 처음 1시작하는 수를 지정한다. 1 allocationSize 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨)\n데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다 50 catalog, schema 데이터베이스 catalog, schema 이름 SEQUENCE 전략과 최적화 SEQUENCE 전략은 데이터베이스 시퀀스를 통해 식별자를 조회하는 추가 작업이 필요하다. 따라서 데이터베이스와 2번 통신한다.\nJPA가 시퀀스에 접근하는 횟수를 줄이기 위해서 allocationSize(기본값 50)를 사용한다.\nallicationSize에 설정한 값 만큼 한번에 시퀀스 값을 증가 시키고, 그만큼 memory에 시퀀스 값을 할당한다. 이후 memory를 활용해 JVM안에서 시퀀스를 할당한다.\n이 방법은 시퀀스 값을 선점하므로 여러 JVM이 동시에 동작해도 기본 키 값이 충돌하지 않는다는 장점이 있다.\nTABLE 전략 키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략 장점: 모든 데이터베이스에 적용 가능 단점: 성능이 떨어진다. TABLE 전략 - 매핑 create table MY_SEQUENCES ( sequence_name varchar(255) not null, next_val bigint, primary key ( sequence_name ) ) @Entity @TableGenerator( name = \"MEMBER_SEQ_GENERATOR\", table = \"MY_SEQUENCES\", pkColumnValue = \"MEMBER_SEQ\", allocationSize = 1) public class Member { @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \"MEMBER_SEQ_GENERATOR\") private Long id; @TableGenerator - 속성 속성 설명 기본값 name 식별자 생성기 이름 필수 table 키생성 테이블 명 hibernate_sequence pkColumnName 시퀀스 컬럼명 sequence_name valueColumnNa 시퀀스 값 컬럼명 next_val pkColumnValue 키로 사용할 값 이름 엔티티 이름 initialValue 초기 값, 마지막으로 생성된 값이 기준이다. 0 allocationSize 시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨) 50 catalog, schema 데이터베이스 catalog, schema 이름 uniqueConstraints(DDL) 유니크 제약 조건을 지정할 수 있다. 권장하는 식별자 전략 기본 키 제약 조건: null 아님, 유일, 변하면 안된다. 미래까지 이 조건을 만족하는 자연키(주민등록 번호 등)는 찾기 어렵다. 대리키(대체키)를 사용하자. 예를 들어 주민등록번호도 기본 키로 적절하기 않다. 권장: Long형(10억 넘어도 동작 가능) + 대체키 + 키 생성전략 사용 실전 예제 - 1. 요구사항 분석과 기본 매핑 요구사항 분석 회원은 상품을 주문할 수 있다. 주문 시 여러 종류의 상품을 선택할 수 있다. 기능 목록 회원 기능 회원등록 회원조회 상품 기능 상품등록 상품수정 상품조회 주문 기능 상품주문 주문내역조회 주문취소 도메인 모델 분석 회원과 주문의 관계: 회원은 여러 번 주문할 수 있다. (일대다) 주문과 상품의 관계: 주문할 때 여러 상품을 선택할 수 있다. 반 대로 같은 상품도 여러 번 주문될 수 있다. 주문상품 이라는 모델 을 만들어서 다대다 관계를 일다대, 다대일 관계로 풀어냄 테이블 설계 엔티티 설계와 매핑 위 실전예제의 코드를 확인하고 싶으면 자바 ORM 표준 JPA 프로그래밍 - 기본편에서 확인하시면 됩니다.\n데이터 중심 설계의 문제점 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식 테이블의 외래키를 객체에 그대로 가져옴 객체 그래프 탐색이 불가능 참조가 없으므로 UML도 잘못됨 ","wordCount":"1352","inLanguage":"en","image":"https://yosong6729.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2024-09-10T21:26:15+09:00","dateModified":"2024-09-10T21:26:15+09:00","author":{"@type":"Person","name":"yosong6729"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yosong6729.github.io/post/%EC%97%94%ED%8B%B0%ED%8B%B0-%EB%A7%A4%ED%95%91/"},"publisher":{"@type":"Organization","name":"Yosong6729 Blog","logo":{"@type":"ImageObject","url":"https://yosong6729.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yosong6729.github.io/ accesskey=h title="Yosong6729 블로그 (Alt + H)"><img src=https://yosong6729.github.io/apple-touch-icon.png alt aria-label=logo height=35>Yosong6729 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://yosong6729.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://yosong6729.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yosong6729.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yosong6729.github.io/post/>Posts</a></div><h1 class="post-title entry-hint-parent">[자바 ORM 표준 JPA 프로그래밍 - 기본편] 엔티티 매핑</h1><div class=post-meta><span title='2024-09-10 21:26:15 +0900 KST'>September 10, 2024</span>&nbsp;·&nbsp;yosong6729&nbsp;|&nbsp;<a href=https://github.com/yosong6729/blog/tree/main/content/post/%ec%97%94%ed%8b%b0%ed%8b%b0%20%eb%a7%a4%ed%95%91/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><ul><li><a href=#%ec%97%94%ed%8b%b0%ed%8b%b0-%eb%a7%a4%ed%95%91 aria-label="엔티티 매핑">엔티티 매핑</a></li><li><a href=#%ea%b0%9d%ec%b2%b4%ec%99%80-%ed%85%8c%ec%9d%b4%eb%b8%94-%eb%a7%a4%ed%95%91 aria-label="객체와 테이블 매핑">객체와 테이블 매핑</a></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%82%a4%eb%a7%88-%ec%9e%90%eb%8f%99-%ec%83%9d%ec%84%b1 aria-label="데이터베이스 스키마 자동 생성">데이터베이스 스키마 자동 생성</a></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%82%a4%eb%a7%88-%ec%9e%90%eb%8f%99-%ec%83%9d%ec%84%b1---%ec%86%8d%ec%84%b1 aria-label="데이터베이스 스키마 자동 생성 - 속성">데이터베이스 스키마 자동 생성 - 속성</a></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0%eb%b2%a0%ec%9d%b4%ec%8a%a4-%ec%8a%a4%ed%82%a4%eb%a7%88-%ec%9e%90%eb%8f%99-%ec%83%9d%ec%84%b1---%ec%a3%bc%ec%9d%98 aria-label="데이터베이스 스키마 자동 생성 - 주의">데이터베이스 스키마 자동 생성 - 주의</a></li><li><a href=#ddl-%ec%83%9d%ec%84%b1-%ea%b8%b0%eb%8a%a5 aria-label="DDL 생성 기능">DDL 생성 기능</a></li><li><a href=#%ed%95%84%eb%93%9c%ec%99%80-%ec%bb%ac%eb%9f%bc-%eb%a7%a4%ed%95%91 aria-label="필드와 컬럼 매핑">필드와 컬럼 매핑</a></li><li><a href=#%eb%a7%a4%ed%95%91-%ec%96%b4%eb%85%b8%ed%85%8c%ec%9d%b4%ec%85%98-%ec%a0%95%eb%a6%ac aria-label="매핑 어노테이션 정리">매핑 어노테이션 정리</a></li><li><a href=#column aria-label=@Column>@Column</a></li><li><a href=#enumerated aria-label=@Enumerated>@Enumerated</a></li><li><a href=#temporal aria-label=Temporal>Temporal</a></li><li><a href=#lob aria-label=@Lob>@Lob</a></li><li><a href=#transient aria-label=@Transient>@Transient</a></li></ul><li><a href=#%ea%b8%b0%eb%b3%b8-%ed%82%a4-%eb%a7%a4%ed%95%91 aria-label="기본 키 매핑">기본 키 매핑</a><ul><li><a href=#%ea%b8%b0%eb%b3%b8-%ed%82%a4-%eb%a7%a4%ed%95%91-%ec%96%b4%eb%85%b8%ed%85%8c%ec%9d%b4%ec%85%98 aria-label="기본 키 매핑 어노테이션">기본 키 매핑 어노테이션</a></li><li><a href=#%ea%b8%b0%eb%b3%b8-%ed%82%a4-%eb%a7%a4%ed%95%91-%eb%b0%a9%eb%b2%95 aria-label="기본 키 매핑 방법">기본 키 매핑 방법</a></li><li><a href=#identity-%ec%a0%84%eb%9e%b5---%ed%8a%b9%ec%a7%95 aria-label="IDENTITY 전략 - 특징">IDENTITY 전략 - 특징</a></li><li><a href=#identity-%ec%a0%84%eb%9e%b5---%eb%a7%a4%ed%95%91 aria-label="IDENTITY 전략 - 매핑">IDENTITY 전략 - 매핑</a></li><li><a href=#sequence-%ec%a0%84%eb%9e%b5---%ed%8a%b9%ec%a7%95 aria-label="SEQUENCE 전략 - 특징">SEQUENCE 전략 - 특징</a></li><li><a href=#sequence-%ec%a0%84%eb%9e%b5---%eb%a7%a4%ed%95%91 aria-label="SEQUENCE 전략 - 매핑">SEQUENCE 전략 - 매핑</a></li><li><a href=#sequence---sequencegenerator aria-label="SEQUENCE - @SequenceGenerator">SEQUENCE - @SequenceGenerator</a></li><li><a href=#sequence-%ec%a0%84%eb%9e%b5%ea%b3%bc-%ec%b5%9c%ec%a0%81%ed%99%94 aria-label="SEQUENCE 전략과 최적화">SEQUENCE 전략과 최적화</a></li><li><a href=#table-%ec%a0%84%eb%9e%b5 aria-label="TABLE 전략">TABLE 전략</a></li><li><a href=#table-%ec%a0%84%eb%9e%b5---%eb%a7%a4%ed%95%91 aria-label="TABLE 전략 - 매핑">TABLE 전략 - 매핑</a></li><li><a href=#tablegenerator---%ec%86%8d%ec%84%b1 aria-label="@TableGenerator - 속성">@TableGenerator - 속성</a></li><li><a href=#%ea%b6%8c%ec%9e%a5%ed%95%98%eb%8a%94-%ec%8b%9d%eb%b3%84%ec%9e%90-%ec%a0%84%eb%9e%b5 aria-label="권장하는 식별자 전략">권장하는 식별자 전략</a></li></ul></li><li><a href=#%ec%8b%a4%ec%a0%84-%ec%98%88%ec%a0%9c---1-%ec%9a%94%ea%b5%ac%ec%82%ac%ed%95%ad-%eb%b6%84%ec%84%9d%ea%b3%bc-%ea%b8%b0%eb%b3%b8-%eb%a7%a4%ed%95%91 aria-label="실전 예제 - 1. 요구사항 분석과 기본 매핑">실전 예제 - 1. 요구사항 분석과 기본 매핑</a><ul><li><a href=#%ec%9a%94%ea%b5%ac%ec%82%ac%ed%95%ad-%eb%b6%84%ec%84%9d aria-label="요구사항 분석">요구사항 분석</a></li><li><a href=#%ea%b8%b0%eb%8a%a5-%eb%aa%a9%eb%a1%9d aria-label="기능 목록">기능 목록</a></li><li><a href=#%eb%8f%84%eb%a9%94%ec%9d%b8-%eb%aa%a8%eb%8d%b8-%eb%b6%84%ec%84%9d aria-label="도메인 모델 분석">도메인 모델 분석</a></li><li><a href=#%ed%85%8c%ec%9d%b4%eb%b8%94-%ec%84%a4%ea%b3%84 aria-label="테이블 설계">테이블 설계</a></li><li><a href=#%ec%97%94%ed%8b%b0%ed%8b%b0-%ec%84%a4%ea%b3%84%ec%99%80-%eb%a7%a4%ed%95%91 aria-label="엔티티 설계와 매핑">엔티티 설계와 매핑</a></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0-%ec%a4%91%ec%8b%ac-%ec%84%a4%ea%b3%84%ec%9d%98-%eb%ac%b8%ec%a0%9c%ec%a0%90 aria-label="데이터 중심 설계의 문제점">데이터 중심 설계의 문제점</a></li></ul></li></ul></div></details></div><div class=post-content><p>해당 글은 김영한님의 <a href=https://www.inflearn.com/course/ORM-JPA-Basic>인프런 강의 자바 ORM 표준 JPA 프로그래밍 - 기본편</a>을 듣고 내용을 정리하기 위한 것으로 자세한 설명은 해당 강의를 통해 확인할 수 있습니다.</p><hr><h3 id=엔티티-매핑>엔티티 매핑<a hidden class=anchor aria-hidden=true href=#엔티티-매핑>#</a></h3><ul><li>객체와 테이블 매핑: @Entity, @Table</li><li>필드와 컬럼 매핑: @Column</li><li>기본 키 매핑: @Id</li><li>연관관계 매핑: @ManyToOne,@JoinColumn</li></ul><h3 id=객체와-테이블-매핑>객체와 테이블 매핑<a hidden class=anchor aria-hidden=true href=#객체와-테이블-매핑>#</a></h3><p><strong>@Entity</strong></p><ul><li>@Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다.</li><li>JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수</li><li>주의<ul><li>기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)</li><li>final 클래스, enum, interface, inner 클래스 사용X</li><li>저장할 필드에 final 사용 X</li></ul></li></ul><p><strong>@Entity</strong> 속성 정리</p><ul><li>속성: name<ul><li>JPA에서 사용할 엔티티 이름을 지정한다.</li><li>기본값: 클래스 이름을 그대로 사용(예: Member)</li><li>같은 클래스 이름이 없으면 가급적 기본값을 사용한다.</li></ul></li></ul><p><strong>@Table</strong></p><ul><li>@Table은 엔티티와 매핑할 테이블 지정<table><thead><tr><th>속성</th><th>기능</th><th>기본값</th></tr></thead><tbody><tr><td>name</td><td>매핑할 테이블 이름</td><td>엔티티 이름을 사용</td></tr><tr><td>catalog</td><td>데이터베이스 catalog 매핑</td><td></td></tr><tr><td>schema</td><td>데이터베이스 schema 매핑</td><td></td></tr><tr><td>uniqueConstraints(DDL)</td><td>DDL 생성 시에 유니크 제약 조건 생성</td><td></td></tr></tbody></table></li></ul><hr><h3 id=데이터베이스-스키마-자동-생성>데이터베이스 스키마 자동 생성<a hidden class=anchor aria-hidden=true href=#데이터베이스-스키마-자동-생성>#</a></h3><p>JPA 사용시 DDL을 애플리케이션 실행 시점에 자동 생성한다.</p><ul><li>테이블 중심 -> 객체 중심</li><li>데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성</li><li>이렇게 <strong>생성된 DDL은 개발 장비에서만 사용(운영에서 사용X)</strong></li><li>생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용</li></ul><h3 id=데이터베이스-스키마-자동-생성---속성>데이터베이스 스키마 자동 생성 - 속성<a hidden class=anchor aria-hidden=true href=#데이터베이스-스키마-자동-생성---속성>#</a></h3><p>hibernate.hbm2ddl.auto</p><table><thead><tr><th>옵션</th><th>설명</th></tr></thead><tbody><tr><td>create</td><td>기존테이블 삭제 후 다시 생성(DROP + CREATE)</td></tr><tr><td>create-drop</td><td>create와 같으나 종료시점에 테이블 DROP</td></tr><tr><td>update</td><td>변경분만 반영(운영DB에는 사용하면 안됨)</td></tr><tr><td>validate</td><td>엔티티와 테이블이 정상 매핑되었는지만 확인</td></tr><tr><td>none</td><td>사용하지 않음</td></tr></tbody></table><h3 id=데이터베이스-스키마-자동-생성---주의>데이터베이스 스키마 자동 생성 - 주의<a hidden class=anchor aria-hidden=true href=#데이터베이스-스키마-자동-생성---주의>#</a></h3><ul><li><strong>운영 장비에는 절대 create, create-drop, update 사용하면 안된다.</strong></li><li>개발 초기 단계는 create 또는 updat</li><li>테스트 서버는 update 또는 validate</li><li>스테이징과 운영 서버는 validate 또는 none</li></ul><hr><h3 id=ddl-생성-기능>DDL 생성 기능<a hidden class=anchor aria-hidden=true href=#ddl-생성-기능>#</a></h3><ul><li>제약조건 추가: 회원 이름은 필수, 10자 초과X<ul><li>@Column(nullable = false, length = 10)</li></ul></li><li>유니크 제약조건 추가<ul><li>Column(unique = true)</li></ul></li></ul><blockquote><p>DDL 생성 기능은 DDL을 자동 생성할 때만 사용되고 JPA의 실행 로직에는 영향을 주지 않는다.</p></blockquote><hr><h3 id=필드와-컬럼-매핑>필드와 컬럼 매핑<a hidden class=anchor aria-hidden=true href=#필드와-컬럼-매핑>#</a></h3><p><strong>요구사항 추가</strong></p><ol><li>회원은 일반 회원과 관리자로 구분해야 한다.</li><li>회원 가입일과 수정일이 있어야 한다.</li><li>회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다.</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Member</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Id</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Column</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;name&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>username</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Integer</span><span class=w> </span><span class=n>age</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Enumerated</span><span class=p>(</span><span class=n>EnumType</span><span class=p>.</span><span class=na>STRING</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>RoleType</span><span class=w> </span><span class=n>roleType</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Temporal</span><span class=p>(</span><span class=n>TemporalType</span><span class=p>.</span><span class=na>TIMESTAMP</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Date</span><span class=w> </span><span class=n>createdDate</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Temporal</span><span class=p>(</span><span class=n>TemporalType</span><span class=p>.</span><span class=na>TIMESTAMP</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Date</span><span class=w> </span><span class=n>lastModifiedDate</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Lob</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>String</span><span class=w> </span><span class=n>description</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>//Getter, Setter… </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><ul><li>@Id는 PK를 매핑 한것이다.</li><li>객체에는 “username”이라고 쓰고 DB 컬럼명으로는 “name”이라고 쓰고 싶으면 @Column(name = “name”)을 사용한다.</li><li>Integer타입을 쓰면 타입과 가장 적절한 숫자 타입이 만들어진다.</li><li>@Enumerated를 사용하면 enum 타입을 사용할수 있다.</li><li>@Temporal을 사용하면 날짜 정보를 저장할수 있다. TemporalType으로는 Date(날짜), Time(시간), TIMESTAMP(날짜, 시간)이 있다.</li><li>varchar을 넘어서는 큰 값을 넣고 싶으면 @Lob을 사용하면 된다.</li></ul><h3 id=매핑-어노테이션-정리>매핑 어노테이션 정리<a hidden class=anchor aria-hidden=true href=#매핑-어노테이션-정리>#</a></h3><p>hibernate.hbm2ddl.auto</p><table><thead><tr><th>어노테이션</th><th>설명</th></tr></thead><tbody><tr><td>@Column</td><td>컬럼 매핑</td></tr><tr><td>@Temporal</td><td>날짜 타입 매핑</td></tr><tr><td>@Enumerated</td><td>enum 타입 매핑</td></tr><tr><td>@Lob</td><td>BLOB, CLOB 매핑</td></tr><tr><td>@Transient</td><td>특정 필드를 컬럼에 매핑하지 않음(매핑 무시)</td></tr></tbody></table><h3 id=column>@Column<a hidden class=anchor aria-hidden=true href=#column>#</a></h3><table><thead><tr><th>속성</th><th>설명</th><th>기본값</th></tr></thead><tbody><tr><td>name</td><td>필드와 매핑할 테이블의 컬럼 이름</td><td>객체의 필드 이름</td></tr><tr><td>insertable,</td><td></td><td></td></tr><tr><td>updatable</td><td>등록, 변경 가능 여부</td><td>TRUE</td></tr><tr><td>nullable(DDL)</td><td>null 값의 허용 여부를 설정한다. false로 설정하면 DDL 생성 시에 not null 제약조건이 붙는다</td><td></td></tr><tr><td>unique(DDL)</td><td>@Table의 uniqueConstraints와 같지만 한 컬럼에 간단히 유니크 제약조건을 걸 때 사용한다.</td><td></td></tr><tr><td>columnDefinition(DDL)</td><td>데이터베이스 컬럼 정보를 직접 줄 수 있다.ex) varchar(100) default ‘EMPTY'</td><td>필드의 자바 타입과 방언 정보를 사용</td></tr><tr><td>length(DDL)</td><td>문자 길이 제약조건, String 타입에만 사용한다.</td><td>255</td></tr><tr><td>precision, scale(DDL)</td><td>BigDecimal 타입에서 사용한다(BigInteger도 사용할 수 있다). precision은 소수점을 포함한 전체 자 릿수를, scale은 소수의 자릿수다. 참고로 double, float 타입에는 적용되지 않는다. 아주 큰 숫자나 정 밀한 소수를 다루어야 할 때만 사용한다.</td><td>precision=19, scale=2</td></tr></tbody></table><blockquote><p>Unique(DDL)은 sql 로그에 유니크 제약조건 이름이 랜덤명처럼 나와서 식별하기 힘들다. 그래서 제약조건 이름 설정이 가능한uniqueConstraints를 사용하는게 좋다.</p></blockquote><h3 id=enumerated>@Enumerated<a hidden class=anchor aria-hidden=true href=#enumerated>#</a></h3><p>자바 enum 타입을 매핑할 때 사용한다.</p><p>주의! ORDINAL 사용X</p><table><thead><tr><th>속성</th><th>설명</th><th>기본값</th></tr></thead><tbody><tr><td>value</td><td>• EnumType.ORDINAL: enum 순서를 데이터베이스에 저장 • EnumType.STRING: enum 이름을 데이터베이스에 저장</td><td>EnumType.ORDINAL</td></tr></tbody></table><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>enum</span><span class=w> </span><span class=n>RoleType</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>USER</span><span class=p>,</span><span class=w> </span><span class=n>ADMIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>ORDINAL을 사용하면 안되는 이유는 만약 위처럼 enum의 값이 있다고 한다면 DB에는 USER는 0, ADMIN은 1이 저장된다. 하지만 이후에 GUEST가 추가되었다고 가정해보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span><span class=w> </span><span class=kd>enum</span><span class=w> </span><span class=n>RoleType</span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//GUEST 추가</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=n>GUEST</span><span class=p>,</span><span class=w> </span><span class=n>USER</span><span class=p>,</span><span class=w> </span><span class=n>ADMIN</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>이렇게 GUEST가 추가가 된다면 DB에 GUEST가 0으로 저장되는데 이전에 저장된 USER의 값도 0이기때문에 큰일이 일어난다.</p><h3 id=temporal>Temporal<a hidden class=anchor aria-hidden=true href=#temporal>#</a></h3><p>날짜 타입(java.util.Date, java.util.Calendar)을 매핑할 때 사용한다</p><blockquote><p><strong>LocalDate, LocalDateTime을 사용할 때는 생략 가능(최신 하이버네이트 지원)</strong></p></blockquote><table><thead><tr><th>속성</th><th>설명</th></tr></thead><tbody><tr><td>value</td><td>•TemporalType.DATE: 날짜, 데이터베이스 date 타입과 매핑(예: 2013–10–11) •TemporalType.TIME: 시간, 데이터베이스 time 타입과 매핑(예: 11:11:11) •TemporalType.TIMESTAMP: 날짜와 시간, 데이터베이스 timestamp 타입과 매핑(예: 2013–10–11 11:11:11)</td></tr></tbody></table><h3 id=lob>@Lob<a hidden class=anchor aria-hidden=true href=#lob>#</a></h3><p>데이터베이스 BLOB, CLOB 타입과 매핑</p><ul><li>@Lob에는 지정할 수 있는 속성이 없다.</li><li>매핑하는 필드 타입이 문자면 CLOB 매핑, 나머지는 BLOB 매핑<ul><li>CLOB: String, char[], java.sql.CLOB</li><li>BLOB: byte[], java.sql. BLOB</li></ul></li></ul><h3 id=transient>@Transient<a hidden class=anchor aria-hidden=true href=#transient>#</a></h3><ul><li>필드 매핑X</li><li>데이터베이스에 저장X, 조회X</li><li>주로 메모리상에서만 임시로 어떤 값을 보관하고 싶을 때 사용</li><li>@Transient<br>private Integer temp;</li></ul><h2 id=기본-키-매핑>기본 키 매핑<a hidden class=anchor aria-hidden=true href=#기본-키-매핑>#</a></h2><h3 id=기본-키-매핑-어노테이션>기본 키 매핑 어노테이션<a hidden class=anchor aria-hidden=true href=#기본-키-매핑-어노테이션>#</a></h3><ul><li>@Id</li><li>@GeneratedValue</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Id</span><span class=w> </span><span class=nd>@GeneratedValue</span><span class=p>(</span><span class=n>strategy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GenerationType</span><span class=p>.</span><span class=na>AUTO</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><h3 id=기본-키-매핑-방법>기본 키 매핑 방법<a hidden class=anchor aria-hidden=true href=#기본-키-매핑-방법>#</a></h3><ul><li>직접 할당: @Id만 사용</li><li>자동 생성(@GeneratedValue)<ul><li>IDENTITY: 데이터베이스에 위임, MYSQL</li><li>SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, ORACLE</li><li>@SequenceGenerator 필요</li><li>TABLE: 키 생성용 테이블 사용, 모든 DB에서 사용</li><li>@TableGenerator 필요</li><li>AUTO: 방언에 따라 자동 지정, 기본값</li></ul></li></ul><hr><h3 id=identity-전략---특징>IDENTITY 전략 - 특징<a hidden class=anchor aria-hidden=true href=#identity-전략---특징>#</a></h3><ul><li>기본 키 생성을 데이터베이스에 위임</li><li>주로 MySQL, PostgreSQL, SQL Server, DB2에서 사용(예: MySQL의 AUTO_ INCREMENT)</li><li>JPA는 보통 트랜잭션 커밋 시점에 INSERT SQL 실행</li><li>AUTO_ INCREMENT는 데이터베이스에 INSERT SQL을 실행한 이후에 ID 값을 알 수 있음</li><li>IDENTITY 전략은 em.persist() 시점에 즉시 INSERT SQL 실행하고 DB에서 식별자를 조회</li></ul><h3 id=identity-전략---매핑>IDENTITY 전략 - 매핑<a hidden class=anchor aria-hidden=true href=#identity-전략---매핑>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Member</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Id</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GeneratedValue</span><span class=p>(</span><span class=n>strategy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GenerationType</span><span class=p>.</span><span class=na>IDENTITY</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w> 
</span></span></span></code></pre></div><hr><h3 id=sequence-전략---특징>SEQUENCE 전략 - 특징<a hidden class=anchor aria-hidden=true href=#sequence-전략---특징>#</a></h3><ul><li>데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트(예: 오라클 시퀀스)</li><li>오라클, PostgreSQL, DB2, H2 데이터베이스에서 사용</li></ul><h3 id=sequence-전략---매핑>SEQUENCE 전략 - 매핑<a hidden class=anchor aria-hidden=true href=#sequence-전략---매핑>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@SequenceGenerator</span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=err>“</span><span class=n>MEMBER_SEQ_GENERATOR</span><span class=s>&#34;, 
</span></span></span><span class=line><span class=cl><span class=s>        sequenceName = “MEMBER_SEQ&#34;</span><span class=p>,</span><span class=w> </span><span class=c1>//매핑할 데이터베이스 시퀀스 이름 </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>initialValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>,</span><span class=w> </span><span class=n>allocationSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Member</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@Id</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nd>@GeneratedValue</span><span class=p>(</span><span class=n>strategy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GenerationType</span><span class=p>.</span><span class=na>SEQUENCE</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>generator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;MEMBER_SEQ_GENERATOR&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p><img loading=lazy src=images/callnextvaluefor.png alt=callnext></p><p>identity와 다르게 em.persist()하는 시점에 데이터베이스 시퀀스를 이용하여 식별자를 조회(call next value for …)한다. 그리고 조회한 식별자를 엔티티에 할당한 후 엔티티 를 영속성 컨텍스트에 저장한다(Identity에서 되지 않는 버퍼링이 가능하다.). 이후 커밋시점에 데이터베이스에 저장한다.</p><h3 id=sequence---sequencegenerator>SEQUENCE - @SequenceGenerator<a hidden class=anchor aria-hidden=true href=#sequence---sequencegenerator>#</a></h3><p>•주의: allocationSize 기본값 = 50</p><table><thead><tr><th>속성</th><th>설명</th><th>기본값</th></tr></thead><tbody><tr><td>name</td><td>식별자 생성기 이름</td><td>필수</td></tr><tr><td>sequenceName</td><td>데잍베이스에 등록되어 있는 시퀀스 이름</td><td>hibernate_sequence</td></tr><tr><td>initialValue</td><td>DDL 생성 시에만 사용됨, 시퀀스 DDL을 생성할 때 처음 1시작하는 수를 지정한다.</td><td>1</td></tr><tr><td>allocationSize</td><td>시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨)<br>데이터베이스 시퀀스 값이 하나씩 증가하도록 설정되어 있으면 이 값을 반드시 1로 설정해야 한다</td><td>50</td></tr><tr><td>catalog, schema</td><td>데이터베이스 catalog, schema 이름</td><td></td></tr></tbody></table><h3 id=sequence-전략과-최적화>SEQUENCE 전략과 최적화<a hidden class=anchor aria-hidden=true href=#sequence-전략과-최적화>#</a></h3><p>SEQUENCE 전략은 데이터베이스 시퀀스를 통해 식별자를 조회하는 추가 작업이 필요하다. 따라서 데이터베이스와 2번 통신한다.</p><p>JPA가 시퀀스에 접근하는 횟수를 줄이기 위해서 allocationSize(기본값 50)를 사용한다.</p><p>allicationSize에 설정한 값 만큼 한번에 시퀀스 값을 증가 시키고, 그만큼 memory에 시퀀스 값을 할당한다. 이후 memory를 활용해 JVM안에서 시퀀스를 할당한다.</p><p>이 방법은 시퀀스 값을 선점하므로 여러 JVM이 동시에 동작해도 기본 키 값이 충돌하지 않는다는 장점이 있다.</p><hr><h3 id=table-전략>TABLE 전략<a hidden class=anchor aria-hidden=true href=#table-전략>#</a></h3><ul><li>키 생성 전용 테이블을 하나 만들어서 데이터베이스 시퀀스를 흉내내는 전략</li><li>장점: 모든 데이터베이스에 적용 가능</li><li>단점: 성능이 떨어진다.</li></ul><h3 id=table-전략---매핑>TABLE 전략 - 매핑<a hidden class=anchor aria-hidden=true href=#table-전략---매핑>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>create</span><span class=w> </span><span class=k>table</span><span class=w> </span><span class=n>MY_SEQUENCES</span><span class=w> </span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>sequence_name</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>255</span><span class=p>)</span><span class=w> </span><span class=k>not</span><span class=w> </span><span class=k>null</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>next_val</span><span class=w> </span><span class=nb>bigint</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>primary</span><span class=w> </span><span class=k>key</span><span class=w> </span><span class=p>(</span><span class=w> </span><span class=n>sequence_name</span><span class=w> </span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Entity</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@TableGenerator</span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;MEMBER_SEQ_GENERATOR&#34;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>table</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;MY_SEQUENCES&#34;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>pkColumnValue</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;MEMBER_SEQ&#34;</span><span class=p>,</span><span class=w> </span><span class=n>allocationSize</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>1</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>class</span> <span class=nc>Member</span><span class=w> </span><span class=p>{</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@Id</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nd>@GeneratedValue</span><span class=p>(</span><span class=n>strategy</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>GenerationType</span><span class=p>.</span><span class=na>TABLE</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>                   </span><span class=n>generator</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;MEMBER_SEQ_GENERATOR&#34;</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>private</span><span class=w> </span><span class=n>Long</span><span class=w> </span><span class=n>id</span><span class=p>;</span><span class=w> 
</span></span></span></code></pre></div><h3 id=tablegenerator---속성>@TableGenerator - 속성<a hidden class=anchor aria-hidden=true href=#tablegenerator---속성>#</a></h3><table><thead><tr><th>속성</th><th>설명</th><th>기본값</th></tr></thead><tbody><tr><td>name</td><td>식별자 생성기 이름</td><td>필수</td></tr><tr><td>table</td><td>키생성 테이블 명</td><td>hibernate_sequence</td></tr><tr><td>pkColumnName</td><td>시퀀스 컬럼명</td><td>sequence_name</td></tr><tr><td>valueColumnNa</td><td>시퀀스 값 컬럼명</td><td>next_val</td></tr><tr><td>pkColumnValue</td><td>키로 사용할 값 이름</td><td>엔티티 이름</td></tr><tr><td>initialValue</td><td>초기 값, 마지막으로 생성된 값이 기준이다.</td><td>0</td></tr><tr><td>allocationSize</td><td>시퀀스 한 번 호출에 증가하는 수(성능 최적화에 사용됨)</td><td>50</td></tr><tr><td></td><td></td><td></td></tr><tr><td>catalog, schema</td><td>데이터베이스 catalog, schema 이름</td><td></td></tr><tr><td>uniqueConstraints(DDL)</td><td>유니크 제약 조건을 지정할 수 있다.</td><td></td></tr></tbody></table><hr><h3 id=권장하는-식별자-전략>권장하는 식별자 전략<a hidden class=anchor aria-hidden=true href=#권장하는-식별자-전략>#</a></h3><ul><li><strong>기본 키 제약 조건</strong>: null 아님, 유일, <strong>변하면 안된다.</strong></li><li>미래까지 이 조건을 만족하는 자연키(주민등록 번호 등)는 찾기 어렵다. 대리키(대체키)를 사용하자.</li><li>예를 들어 주민등록번호도 기본 키로 적절하기 않다.</li><li><strong>권장: Long형(10억 넘어도 동작 가능) + 대체키 + 키 생성전략 사용</strong></li></ul><hr><h2 id=실전-예제---1-요구사항-분석과-기본-매핑>실전 예제 - 1. 요구사항 분석과 기본 매핑<a hidden class=anchor aria-hidden=true href=#실전-예제---1-요구사항-분석과-기본-매핑>#</a></h2><h3 id=요구사항-분석>요구사항 분석<a hidden class=anchor aria-hidden=true href=#요구사항-분석>#</a></h3><ul><li>회원은 상품을 주문할 수 있다.</li><li>주문 시 여러 종류의 상품을 선택할 수 있다.</li></ul><h3 id=기능-목록>기능 목록<a hidden class=anchor aria-hidden=true href=#기능-목록>#</a></h3><ul><li>회원 기능<ul><li>회원등록</li><li>회원조회</li></ul></li><li>상품 기능<ul><li>상품등록</li><li>상품수정</li><li>상품조회</li></ul></li><li>주문 기능<ul><li>상품주문</li><li>주문내역조회</li><li>주문취소</li></ul></li></ul><p><img loading=lazy src=images/%ea%b8%b0%eb%8a%a5%20%eb%aa%a9%eb%a1%9d.png alt=image.png></p><h3 id=도메인-모델-분석>도메인 모델 분석<a hidden class=anchor aria-hidden=true href=#도메인-모델-분석>#</a></h3><ul><li>회원과 주문의 관계: 회원은 여러 번 주문할 수 있다. (일대다)</li><li>주문과 상품의 관계: 주문할 때 여러 상품을 선택할 수 있다. 반
대로 같은 상품도 여러 번 주문될 수 있다. 주문상품 이라는 모델
을 만들어서 다대다 관계를 일다대, 다대일 관계로 풀어냄</li></ul><p><img loading=lazy src=images/%eb%8f%84%eb%a9%94%ec%9d%b8%20%eb%aa%a8%eb%8d%b8%20%eb%b6%84%ec%84%9d.png alt=image.png></p><h3 id=테이블-설계>테이블 설계<a hidden class=anchor aria-hidden=true href=#테이블-설계>#</a></h3><p><img loading=lazy src=images/%ed%85%8c%ec%9d%b4%eb%b8%94%20%ec%84%a4%ea%b3%84.png alt=image.png></p><h3 id=엔티티-설계와-매핑>엔티티 설계와 매핑<a hidden class=anchor aria-hidden=true href=#엔티티-설계와-매핑>#</a></h3><p><img loading=lazy src=images/%ec%97%94%ed%8b%b0%ed%8b%b0%20%ec%84%a4%ea%b3%84%ec%99%80%20%eb%a7%a4%ed%95%91.png alt=image.png></p><blockquote><p>위 실전예제의 코드를 확인하고 싶으면  <a href=https://www.inflearn.com/course/ORM-JPA-Basic>자바 ORM 표준 JPA 프로그래밍 - 기본편</a>에서 확인하시면 됩니다.</p></blockquote><h3 id=데이터-중심-설계의-문제점>데이터 중심 설계의 문제점<a hidden class=anchor aria-hidden=true href=#데이터-중심-설계의-문제점>#</a></h3><ul><li>현재 방식은 객체 설계를 테이블 설계에 맞춘 방식</li><li>테이블의 외래키를 객체에 그대로 가져옴</li><li>객체 그래프 탐색이 불가능</li><li>참조가 없으므로 UML도 잘못됨</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://yosong6729.github.io/tags/jpa/>JPA</a></li></ul><nav class=paginav><a class=next href=https://yosong6729.github.io/post/%EC%98%81%EC%86%8D%EC%84%B1/%EC%98%81%EC%86%8D%EC%84%B1/><span class=title>Next »</span><br><span>[자바 ORM 표준 JPA 프로그래밍 - 기본편] 영속성 관리</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://yosong6729.github.io/>Yosong6729 Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>